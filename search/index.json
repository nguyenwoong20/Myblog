[{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 🚀 Tại sao cần NodeJS?\rNodeJS cho phép JavaScript chạy trên máy tính (không chỉ trình duyệt).\n📥 Cách cài đặt NodeJS\rVào https://nodejs.org Tải phiên bản LTS (khuyên dùng) Cài đặt bình thường (Next → Next → Install) ✅ Kiểm tra cài đặt\rMở Command Prompt và chạy:\nnode --version npm --version Kết quả mong đợi:\nv18.17.0 # NodeJS 9.6.7 # npm Extensions hữu ích:\nJavaScript (ES6) code snippets Bracket Pair Colorizer Live Server Prettier - Code formatter Lựa chọn khác:\rWebStorm (trả phí, rất mạnh) Sublime Text (nhẹ, nhanh) Atom (miễn phí, tùy biến cao) 🎯 Chuẩn bị cho bài tiếp theo\rSau khi cài đặt xong, bạn đã sẵn sàng để:\n✅ Chạy code JavaScript trên máy tính ✅ Sử dụng npm để cài đặt packages ✅ Bắt đầu hành trình học JavaScript 💡 Tip cho người mới\r// Tạo thư mục cho dự án học tập mkdir javascript-learning cd javascript-learning // Tạo file đầu tiên touch hello.js // macOS/Linux echo. \u0026gt; hello.js // Windows 🔥 Thử thách nhỏ\r🏆 Tóm tắt\r✅ NodeJS cho phép chạy JavaScript trên máy tính\n✅ Tải phiên bản LTS từ nodejs.org\n✅ Kiểm tra cài đặt bằng node --version\n📚 Bài tiếp theo\r👉 Bài 2: Chạy chương trình JavaScript cơ bản bằng Node - Tạo và chạy file JavaScript đầu tiên của bạn!\n","date":"2025-09-28T09:00:00+07:00","image":"https://img.youtube.com/vi/lwsS-ikKnPs/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-1-t%E1%BA%A3i-c%C3%A0i-%C4%91%E1%BA%B7t-nodejs-kh%E1%BB%9Fi-%C4%91%E1%BA%A7u-h%C3%A0nh-tr%C3%ACnh-javascript/","title":"Bài 1 - Tải \u0026 Cài Đặt NodeJS - Khởi Đầu Hành Trình JavaScript"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Tạo file JavaScript đầu tiên\rMở Terminal hoặc VS Code.\nLệnh tạo thư mục và di chuyển vào thư mục mới:\nmkdir my-first-js cd my-first-js Tạo file mới: hello.js\n2. Code Hello World đơn giản\r// In ra màn hình console.log(\u0026#34;Hello, JavaScript!\u0026#34;); console.log(\u0026#34;Chào mừng bạn đến với NodeJS.\u0026#34;); 3. Chạy file bằng NodeJS\rTrong terminal, chạy:\nnode hello.js Kết quả:\nHello, JavaScript!\rChào mừng bạn đến với NodeJS. 4. Sử dụng console.log\rIn bất cứ thứ gì lên màn hình console:\nconsole.log(\u0026#34;Thông báo\u0026#34;); console.log(123); console.log(true); 5. Thông tin hệ thống bằng process.version, process.platform\rconsole.log(\u0026#34;Phiên bản NodeJS:\u0026#34;, process.version); console.log(\u0026#34;OS:\u0026#34;, process.platform); 6. Hướng dẫn chạy với REPL\rGõ lệnh node và thử trực tiếp:\n\u0026gt; console.log(\u0026#34;Hello trực tiếp\u0026#34;); \u0026gt; 1 + 2 7. Debug nhanh\rNếu thấy lỗi về tên file, cú pháp hoặc biến chưa khai báo: kiểm tra lại chính xác tên file, dấu ngoặc, khai báo biến.\nĐảm bảo file lưu dưới dạng .js.\n8. Bài tập nhỏ\rTạo file about-me.js:\nconsole.log(\u0026#34;Tên:\u0026#34;, \u0026#34;Tên của bạn\u0026#34;); console.log(\u0026#34;Tuổi:\u0026#34;, 20); console.log(\u0026#34;Nghề nghiệp:\u0026#34;, \u0026#34;Học lập trình\u0026#34;); Tạo file calculator.js:\nlet a = 10, b = 3; console.log(\u0026#34;a + b =\u0026#34;, a + b); console.log(\u0026#34;a - b =\u0026#34;, a - b); Chốt lại:\rBài 2 giúp bạn làm chủ cách tạo \u0026amp; chạy file JavaScript đầu tiên bằng NodeJS, sử dụng console.log để xuất dữ liệu, thao tác và debug đơn giản, đặt nền móng cho các bài học kế tiếp.\n📚 Bài tiếp theo\r👉 Bài 3: Biến và Hằng số - Tìm hiểu cách lưu trữ và sử dụng dữ liệu trong JavaScript!\n","date":"2025-09-28T09:30:00+07:00","image":"https://img.youtube.com/vi/cbZfmmIlzaU/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-2-ch%E1%BA%A1y-ch%C6%B0%C6%A1ng-tr%C3%ACnh-javascript-c%C6%A1-b%E1%BA%A3n-b%E1%BA%B1ng-node/","title":"Bài 2 - Chạy Chương Trình JavaScript Cơ Bản Bằng Node"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Biến là gì?\rBiến (Variable) là \u0026ldquo;hộp chứa\u0026rdquo; để lưu trữ dữ liệu trong chương trình.\n2. Khai báo biến với let\rlet name = \u0026#34;Code Thu\u0026#34;; let age = 25; let isStudent = true; console.log(name); // \u0026#34;Code Thu\u0026#34; console.log(age); // 25 Khai báo không gán giá trị:\rlet userName; // undefined userName = \u0026#34;John Doe\u0026#34;; // Gán giá trị sau 3. Hằng số với const\rHằng số (Constant) là biến không thể thay đổi giá trị sau khi khai báo:\nconst PI = 3.14159; const COMPANY_NAME = \u0026#34;Tech Corp\u0026#34;; console.log(PI); // 3.14159 // ❌ Lỗi! Không thể thay đổi PI = 3.14; // TypeError 4. Thay đổi giá trị biến\rlet score = 0; score = 10; // Gán giá trị mới score += 5; // Cộng thêm 5 console.log(score); // 15 5. Các kiểu dữ liệu cơ bản\r// String (Chuỗi) let message = \u0026#34;Hello World\u0026#34;; let template = `Template với ${message}`; // Number (Số) let age = 25; let price = 99.99; // Boolean (Đúng/Sai) let isActive = true; let isComplete = false; // Undefined let notDefined; console.log(typeof notDefined); // \u0026#34;undefined\u0026#34; 6. Quy tắc đặt tên biến\r✅ Đúng:\nuserName (camelCase) isLoggedIn (có ý nghĩa) totalPrice (mô tả rõ ràng) ❌ Sai:\n123abc (không bắt đầu bằng số) user-name (không dùng dấu gạch ngang) class (từ khóa dành riêng) 7. Kiểm tra kiểu dữ liệu\rlet name = \u0026#34;JavaScript\u0026#34;; let age = 25; let isActive = true; console.log(typeof name); // \u0026#34;string\u0026#34; console.log(typeof age); // \u0026#34;number\u0026#34; console.log(typeof isActive); // \u0026#34;boolean\u0026#34; 8. Bài tập nhỏ\rTạo file student-info.js:\nconst STUDENT_ID = \u0026#34;SV001\u0026#34;; let studentName = \u0026#34;Nguyen Van A\u0026#34;; let currentGrade = 8.5; let age = 20; console.log(\u0026#34;Mã SV:\u0026#34;, STUDENT_ID); console.log(\u0026#34;Họ tên:\u0026#34;, studentName); console.log(\u0026#34;Tuổi:\u0026#34;, age); console.log(\u0026#34;Điểm TB:\u0026#34;, currentGrade); Chốt lại:\rBài 3 giúp bạn hiểu cách khai báo và sử dụng biến (let) và hằng số (const) trong JavaScript, các kiểu dữ liệu cơ bản, quy tắc đặt tên biến, và cách kiểm tra kiểu dữ liệu với typeof.\n📚 Bài tiếp theo\r👉 Bài 4: Khởi tạo biến bằng var và let - So sánh sự khác biệt giữa var và let, tại sao nên dùng let!\n","date":"2025-09-28T10:00:00+07:00","image":"https://img.youtube.com/vi/5S2UOHZE5M0/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-3-bi%E1%BA%BFn-v%C3%A0-h%E1%BA%B1ng-s%E1%BB%91-n%C6%A1i-l%C6%B0u-tr%E1%BB%AF-d%E1%BB%AF-li%E1%BB%87u/","title":"Bài 3 - Biến và Hằng Số - Nơi Lưu Trữ Dữ Liệu"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Tại sao có var và let?\rJavaScript có 3 cách khai báo biến:\nvar - Cách cũ (ES5) let - Cách mới (ES6/ES2015) const - Cho hằng số Khuyến nghị: Dùng let thay vì var\n🤔 Tại sao có 2 cách khai báo biến?\rJavaScript có 3 cách khai báo biến:\nvar - Cách cũ (ES5 và trước đó) let - Cách mới (ES6/ES2015) const - Cho hằng số (ES6/ES2015) 📊 So sánh var vs let\rĐặc điểm var let Scope Function scope Block scope Hoisting Có, với undefined Có, nhưng TDZ Re-declaration Được phép Không được Cập nhật giá trị Được phép Được phép Khuyến nghị ❌ Không nên dùng ✅ Nên dùng 2. Function Scope vs Block Scope\rvar - Function Scope:\rif (true) { var x = 1; } console.log(x); // 1 - Truy cập được! let - Block Scope:\rif (true) { let y = 1; } console.log(y); // ❌ Lỗi! y is not defined 3. Hoisting (Đưa lên đầu)\rvar - Hoisting với undefined:\rconsole.log(varVariable); // undefined (không lỗi) var varVariable = \u0026#34;Hello\u0026#34;; let - Temporal Dead Zone:\rconsole.log(letVariable); // ❌ Lỗi! let letVariable = \u0026#34;Hello\u0026#34;; 🚫 3. Re-declaration (Khai báo lại)\rvar - Cho phép khai báo lại\rvar name = \u0026#34;John\u0026#34;; var name = \u0026#34;Jane\u0026#34;; // ✅ OK console.log(name); // \u0026#34;Jane\u0026#34; var age = 25; var age = 30; // ✅ OK, không báo lỗi console.log(age); // 30 let - Không cho phép khai báo lại\rlet name = \u0026#34;John\u0026#34;; let name = \u0026#34;Jane\u0026#34;; // ❌ SyntaxError: Identifier \u0026#39;name\u0026#39; has already been declared let age = 25; age = 30; // ✅ OK - Chỉ cập nhật giá trị console.log(age); // 30 5. Vòng lặp - Ví dụ thực tế\rVấn đề với var:\rfor (var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(\u0026#34;var:\u0026#34;, i); // In ra: 3, 3, 3 }, 100); } Giải pháp với let:\rfor (let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(\u0026#34;let:\u0026#34;, i); // In ra: 0, 1, 2 }, 100); } 6. Best Practices\rThứ tự ưu tiên:\nconst - Cho giá trị không đổi let - Cho biến thay đổi var - ❌ Tránh sử dụng // ✅ Tốt const API_URL = \u0026#34;https://api.example.com\u0026#34;; let userName = \u0026#34;john\u0026#34;; // ❌ Tránh var oldStyle = \u0026#34;avoid this\u0026#34;; 7. Bài tập nhỏ\rTìm lỗi trong code:\nfunction buggyCode() { console.log(message); // Lỗi gì? let message = \u0026#34;Hello\u0026#34;; if (true) { var x = 1; let y = 2; } console.log(x); // Có lỗi không? console.log(y); // Có lỗi không? } Chốt lại:\rBài 4 giúp bạn hiểu sự khác biệt giữa var và let: var có function scope và hoisting với undefined, let có block scope và Temporal Dead Zone. Nên sử dụng let/const thay vì var để code an toàn và dễ debug hơn.\n📚 Bài tiếp theo\r👉 Bài 5: Toán tử gán và toán tử so sánh - Học cách thực hiện phép toán và so sánh trong JavaScript!\n","date":"2025-09-28T10:30:00+07:00","image":"https://img.youtube.com/vi/kfibc_7N69o/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-4-kh%E1%BB%9Fi-t%E1%BA%A1o-bi%E1%BA%BFn-v%E1%BB%9Bi-var-v%C3%A0-let-s%E1%BB%B1-kh%C3%A1c-bi%E1%BB%87t-quan-tr%E1%BB%8Dng/","title":"Bài 4 - Khởi Tạo Biến Với var và let - Sự Khác Biệt Quan Trọng"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Toán tử số học\rlet a = 10, b = 3; console.log(a + b); // 13 - Cộng console.log(a - b); // 7 - Trừ console.log(a * b); // 30 - Nhân console.log(a / b); // 3.33 - Chia console.log(a % b); // 1 - Chia lấy dư console.log(a ** b); // 1000 - Lũy thừa Toán tử tăng/giảm:\rlet count = 5; console.log(count++); // 5 (dùng trước, tăng sau) console.log(++count); // 7 (tăng trước, dùng sau) 2. Toán tử gán\rGán cơ bản:\rlet x = 10; let name = \u0026#34;John\u0026#34;; let isActive = true; Toán tử gán kết hợp:\rlet score = 100; score += 50; // score = score + 50 score -= 30; // score = score - 30 score *= 2; // score = score * 2 score /= 4; // score = score / 4 3. Toán tử so sánh\rlet a = 5, b = \u0026#34;5\u0026#34;, c = 10; // So sánh giá trị console.log(a == b); // true (5 == \u0026#34;5\u0026#34;) console.log(a === b); // false (khác kiểu) console.log(a != b); // false console.log(a !== b); // true // So sánh lớn hơn, nhỏ hơn console.log(a \u0026gt; c); // false console.log(a \u0026lt; c); // true console.log(a \u0026gt;= 5); // true console.log(a \u0026lt;= 10); // true 4. Sự khác biệt == vs ===\r== (Loose Equality):\rconsole.log(5 == \u0026#34;5\u0026#34;); // true (tự động chuyển đổi kiểu) console.log(true == 1); // true console.log(\u0026#34;\u0026#34; == 0); // true === (Strict Equality) - Khuyên dùng:\rconsole.log(5 === \u0026#34;5\u0026#34;); // false (khác kiểu) console.log(true === 1); // false console.log(\u0026#34;\u0026#34; === 0); // false 5. Thứ tự ưu tiên toán tử\rlet result = 2 + 3 * 4; // 14 (không phải 20) let result2 = (2 + 3) * 4; // 20 (có dấu ngoặc) Thứ tự ưu tiên: () → ** → *, /, % → +, - → so sánh → === → gán\n6. Bài tập nhỏ\rTính toán hóa đơn:\nconst PRICE = 500000; let quantity = 2; let discount = 10; // % let subtotal = PRICE * quantity; let discountAmount = subtotal * (discount / 100); let total = subtotal - discountAmount; console.log(\u0026#34;Tạm tính:\u0026#34;, subtotal, \u0026#34;VND\u0026#34;); console.log(\u0026#34;Giảm giá:\u0026#34;, discountAmount, \u0026#34;VND\u0026#34;); console.log(\u0026#34;Tổng cộng:\u0026#34;, total, \u0026#34;VND\u0026#34;); Chốt lại:\rBài 5 giúp bạn hiểu các toán tử số học (+, -, *, /, %), toán tử gán (=, +=, -=), toán tử so sánh (===, !==, \u0026gt;, \u0026lt;), sự khác biệt giữa == và ===, và thứ tự ưu tiên toán tử trong JavaScript.\n📚 Bài tiếp theo\r👉 Bài 6: Kiểu dữ liệu số Number - Tìm hiểu chi tiết về số trong JavaScript!\n","date":"2025-09-28T11:00:00+07:00","image":"https://img.youtube.com/vi/N2QqCxjz-hY/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-5-to%C3%A1n-t%E1%BB%AD-g%C3%A1n-v%C3%A0-to%C3%A1n-t%E1%BB%AD-so-s%C3%A1nh-ph%C3%A9p-to%C3%A1n-c%C6%A1-b%E1%BA%A3n/","title":"Bài 5 - Toán Tử Gán và Toán Tử So Sánh - Phép Toán Cơ Bản"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 🔢 Number trong JavaScript\rNumber là kiểu dữ liệu để biểu diễn tất cả các loại số trong JavaScript.\nlet integer = 42; // Số nguyên let decimal = 3.14; // Số thập phân let negative = -17; // Số âm console.log(typeof integer); // \u0026#34;number\u0026#34; 🚫 Giá trị đặc biệt\rNaN (Not a Number):\nconsole.log(0 / 0); // NaN console.log(\u0026#34;hello\u0026#34; * 5); // NaN console.log(isNaN(NaN)); // true Infinity:\nconsole.log(1 / 0); // Infinity console.log(-1 / 0); // -Infinity 🧮 Object Math\rconsole.log(Math.PI); // 3.141592653589793 console.log(Math.round(4.7)); // 5 (làm tròn) console.log(Math.floor(4.7)); // 4 (làm tròn xuống) console.log(Math.ceil(4.7)); // 5 (làm tròn lên) console.log(Math.max(1,2,3)); // 3 console.log(Math.min(1,2,3)); // 1 Phương thức tính toán:\r🔄 Chuyển đổi sang Number\rlet str = \u0026#34;123\u0026#34;; console.log(Number(str)); // 123 console.log(parseInt(\u0026#34;123px\u0026#34;)); // 123 console.log(parseFloat(\u0026#34;3.14kg\u0026#34;)); // 3.14 console.log(Number(true)); // 1 console.log(Number(false)); // 0 🏋️ Bài tập thực hành\r// Tính BMI let weight = 70; // kg let height = 1.75; // m let bmi = weight / Math.pow(height, 2); console.log(\u0026#34;BMI:\u0026#34;, bmi.toFixed(1)); // Số ngẫu nhiên từ 1-10 let random = Math.floor(Math.random() * 10) + 1; console.log(\u0026#34;Random:\u0026#34;, random); 🏆 Tóm tắt\r✅ Number là kiểu dữ liệu duy nhất cho số\n✅ Math object cung cấp hằng số và phương thức toán học\n✅ NaN và Infinity là giá trị đặc biệt\n✅ Chuyển đổi bằng Number(), parseInt(), parseFloat()\n📚 Bài tiếp theo\r👉 Bài 7: Khái quát kiểu dữ liệu Chuỗi (String) - Tìm hiểu chi tiết về xử lý chuỗi trong JavaScript!\n","date":"2025-09-28T11:30:00+07:00","image":"https://img.youtube.com/vi/bynuI8B2uho/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-6-ki%E1%BB%83u-d%E1%BB%AF-li%E1%BB%87u-s%E1%BB%91-number-l%C3%A0m-ch%E1%BB%A7-s%E1%BB%91-h%E1%BB%8Dc-javascript/","title":"Bài 6 - Kiểu Dữ Liệu Số Number - Làm Chủ Số Học JavaScript"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. String trong JavaScript\rString (chuỗi) là kiểu dữ liệu để lưu trữ văn bản.\n2. Cách tạo String\r// Single quotes let singleQuote = \u0026#39;Hello World\u0026#39;; // Double quotes let doubleQuote = \u0026#34;Hello World\u0026#34;; // Template literals (backticks) let templateString = `Hello World`; let multiLine = `Dòng 1 Dòng 2`; console.log(typeof singleQuote); // \u0026#34;string\u0026#34; 3. Nối chuỗi\rCách 1: Toán tử +\rlet firstName = \u0026#34;Nguyen\u0026#34;; let lastName = \u0026#34;Van A\u0026#34;; let fullName = firstName + \u0026#34; \u0026#34; + lastName; console.log(fullName); // \u0026#34;Nguyen Van A\u0026#34; Cách 2: Template literals (khuyên dùng)\rlet name = \u0026#34;John\u0026#34;, age = 30; let intro = `Tôi là ${name}, ${age} tuổi`; console.log(intro); // \u0026#34;Tôi là John, 30 tuổi\u0026#34; 4. Thuộc tính và phương thức String\rĐộ dài chuỗi:\rlet text = \u0026#34;JavaScript\u0026#34;; console.log(text.length); // 10 Truy cập ký tự:\rlet word = \u0026#34;Hello\u0026#34;; console.log(word[0]); // \u0026#34;H\u0026#34; console.log(word.charAt(0)); // \u0026#34;H\u0026#34; console.log(word[word.length - 1]); // \u0026#34;o\u0026#34; 5. Tìm kiếm trong chuỗi\rlet text = \u0026#34;JavaScript Programming\u0026#34;; // indexOf() - Tìm vị trí console.log(text.indexOf(\u0026#34;Script\u0026#34;)); // 4 console.log(text.indexOf(\u0026#34;Python\u0026#34;)); // -1 (không tìm thấy) // includes() - Kiểm tra có chứa console.log(text.includes(\u0026#34;Java\u0026#34;)); // true console.log(text.includes(\u0026#34;Python\u0026#34;)); // false // startsWith(), endsWith() console.log(text.startsWith(\u0026#34;Java\u0026#34;)); // true console.log(text.endsWith(\u0026#34;ing\u0026#34;)); // true 6. Cắt và thay đổi chuỗi\rlet text = \u0026#34;JavaScript Programming\u0026#34;; // Cắt chuỗi console.log(text.substring(0, 10)); // \u0026#34;JavaScript\u0026#34; console.log(text.slice(4, 10)); // \u0026#34;Script\u0026#34; // Chuyển đổi hoa/thường console.log(text.toLowerCase()); // \u0026#34;javascript programming\u0026#34; console.log(text.toUpperCase()); // \u0026#34;JAVASCRIPT PROGRAMMING\u0026#34; // Loại bỏ khoảng trắng let messyText = \u0026#34; Hello World \u0026#34;; console.log(messyText.trim()); // \u0026#34;Hello World\u0026#34; // Thay thế console.log(text.replace(\u0026#34;Java\u0026#34;, \u0026#34;Type\u0026#34;)); // \u0026#34;TypeScript Programming\u0026#34; 7. Tách chuỗi\rlet csv = \u0026#34;Apple,Banana,Orange\u0026#34;; let fruits = csv.split(\u0026#34;,\u0026#34;); console.log(fruits); // [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;] let sentence = \u0026#34;Hello World\u0026#34;; let words = sentence.split(\u0026#34; \u0026#34;); console.log(words); // [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;] 8. Bài tập nhỏ\rXử lý thông tin người dùng:\nfunction processName(rawName) { return rawName .trim() .split(\u0026#34; \u0026#34;) .map(word =\u0026gt; word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()) .join(\u0026#34; \u0026#34;); } console.log(processName(\u0026#34; jOhN dOe \u0026#34;)); // \u0026#34;John Doe\u0026#34; Chốt lại:\rBài 7 giúp bạn hiểu về kiểu dữ liệu String, cách tạo chuỗi (single quotes, double quotes, template literals), nối chuỗi, các phương thức quan trọng như length, charAt, indexOf, includes, substring, split, và cách xử lý chuỗi trong thực tế.\n📚 Bài tiếp theo\r👉 Bài 8: Template Literals, Number-String - Tìm hiểu sâu về template literals và chuyển đổi giữa Number-String!\n","date":"2025-09-28T12:00:00+07:00","image":"https://img.youtube.com/vi/0ABTCy5FbP4/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-7-kh%C3%A1i-qu%C3%A1t-ki%E1%BB%83u-d%E1%BB%AF-li%E1%BB%87u-chu%E1%BB%97i-string-x%E1%BB%AD-l%C3%BD-v%C4%83n-b%E1%BA%A3n/","title":"Bài 7 - Khái Quát Kiểu Dữ Liệu Chuỗi (String) - Xử Lý Văn Bản"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Template Literals - Cách mới tạo String\rTemplate Literals sử dụng backticks (`) thay vì quotes:\nCách cũ (ES5):\rlet name = \u0026#34;John\u0026#34;, age = 25; let oldWay = \u0026#34;Xin chào, tôi là \u0026#34; + name + \u0026#34;, \u0026#34; + age + \u0026#34; tuổi.\u0026#34;; Cách mới (ES6):\rlet name = \u0026#34;John\u0026#34;, age = 25; let newWay = `Xin chào, tôi là ${name}, ${age} tuổi.`; 2. String Interpolation với $\rlet product = \u0026#34;iPhone\u0026#34;, price = 25000000, quantity = 2; let invoice = `Sản phẩm: ${product} Giá: ${price.toLocaleString(\u0026#39;vi-VN\u0026#39;)} VND Số lượng: ${quantity} Thành tiền: ${(price * quantity).toLocaleString(\u0026#39;vi-VN\u0026#39;)} VND`; console.log(invoice); Gọi hàm trong template:\rfunction getDiscount(price) { return price \u0026gt; 1000000 ? 10 : 5; } let message = `Giảm giá: ${getDiscount(25000000)}% Thời gian: ${new Date().toLocaleString(\u0026#39;vi-VN\u0026#39;)}`; 3. Multi-line Strings\rlet userName = \u0026#34;John Doe\u0026#34;, userEmail = \u0026#34;john@example.com\u0026#34;; let htmlTemplate = ` \u0026lt;div class=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Welcome, ${userName}!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Email: ${userEmail}\u0026lt;/p\u0026gt; \u0026lt;button onclick=\u0026#34;logout()\u0026#34;\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`; console.log(htmlTemplate); 4. Chuyển đổi Number ↔ String\rString to Number:\rlet str1 = \u0026#34;123\u0026#34;, str2 = \u0026#34;45.67\u0026#34;, str3 = \u0026#34;123abc\u0026#34;; // Number() - Nghiêm ngặt console.log(Number(str1)); // 123 console.log(Number(str3)); // NaN // parseInt(), parseFloat() - Lấy số từ đầu console.log(parseInt(str3)); // 123 (bỏ phần chữ) console.log(parseFloat(str2)); // 45.67 // Unary operator + - Ngắn gọn console.log(+str1); // 123 Number to String:\rlet num = 123.456; console.log(num.toString()); // \u0026#34;123.456\u0026#34; console.log(String(num)); // \u0026#34;123.456\u0026#34; console.log(`${num}`); // \u0026#34;123.456\u0026#34; (template literal) console.log(num + \u0026#34;\u0026#34;); // \u0026#34;123.456\u0026#34; (nối chuỗi rỗng) Formatting Numbers:\rlet number = 1234567.89; console.log(number.toFixed(2)); // \u0026#34;1234567.89\u0026#34; console.log(number.toLocaleString(\u0026#39;vi-VN\u0026#39;)); // \u0026#34;1.234.567,89\u0026#34; 5. Bài tập nhỏ\rTạo template HTML:\nfunction createUserCard(user) { return ` \u0026lt;div class=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;${user.name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;Email: ${user.email}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Role: ${user.role}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;`; } let user = { name: \u0026#34;John\u0026#34;, email: \u0026#34;john@email.com\u0026#34;, role: \u0026#34;Admin\u0026#34; }; console.log(createUserCard(user)); Format số tiền:\nfunction formatMoney(amount) { return `${amount.toLocaleString(\u0026#39;vi-VN\u0026#39;)} VND`; } console.log(formatMoney(1234567)); // \u0026#34;1.234.567 VND\u0026#34; Chốt lại:\rBài 8 giúp bạn hiểu Template Literals với backticks và ${} để nhúng biểu thức, tạo multi-line strings, chuyển đổi giữa Number và String bằng Number(), parseInt(), parseFloat(), toString(), và cách format số với toFixed(), toLocaleString().\n📚 Bài tiếp theo\r👉 Bài 9: Kiểu dữ liệu Boolean - Tìm hiểu về logic đúng/sai và các phép toán Boolean!\n","date":"2025-09-28T12:30:00+07:00","image":"https://img.youtube.com/vi/hiFBsPtFgOg/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-8-template-literals-number-string-c%C3%B4ng-c%E1%BB%A5-m%E1%BA%A1nh-m%E1%BA%BD-es6/","title":"Bài 8 - Template Literals, Number-String - Công Cụ Mạnh Mẽ ES6"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Boolean trong JavaScript\rBoolean là kiểu dữ liệu logic chỉ có 2 giá trị:\ntrue - Đúng false - Sai 2. Cách tạo Boolean\rTrực tiếp:\rlet isActive = true; let isComplete = false; console.log(typeof isActive); // \u0026#34;boolean\u0026#34; Từ so sánh:\rlet age = 25, minAge = 18; let isAdult = age \u0026gt;= minAge; // true let isChild = age \u0026lt; minAge; // false Từ hàm Boolean():\rconsole.log(Boolean(1)); // true console.log(Boolean(0)); // false console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean(\u0026#34;\u0026#34;)); // false 3. Truthy và Falsy Values\rFalsy Values (luôn là false):\rconsole.log(Boolean(false)); // false console.log(Boolean(0)); // false console.log(Boolean(\u0026#34;\u0026#34;)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(NaN)); // false Truthy Values (tất cả còn lại):\rconsole.log(Boolean(1)); // true console.log(Boolean(\u0026#34;hello\u0026#34;)); // true console.log(Boolean([])); // true 4. Toán tử Logic\rAND (\u0026amp;\u0026amp;) - Cả hai phải đúng:\rlet age = 25, hasLicense = true; let canDrive = age \u0026gt;= 18 \u0026amp;\u0026amp; hasLicense; // true OR (||) - Một trong hai đúng:\rlet isWeekend = false, isHoliday = true; let canRest = isWeekend || isHoliday; // true // Default values let userName = null; let displayName = userName || \u0026#34;Khách\u0026#34;; // \u0026#34;Khách\u0026#34; NOT (!) - Đảo ngược:\rlet isLoggedIn = false; let needsLogin = !isLoggedIn; // true // Chuyển về boolean console.log(!!\u0026#34;hello\u0026#34;); // true console.log(!!0); // false 5. Short-circuit Evaluation\r\u0026amp;\u0026amp; - Dừng khi gặp falsy:\rlet user = { name: \u0026#34;John\u0026#34;, profile: { email: \u0026#34;john@example.com\u0026#34; } }; // Safe navigation console.log(user \u0026amp;\u0026amp; user.profile \u0026amp;\u0026amp; user.profile.email); // \u0026#34;john@example.com\u0026#34; // Conditional execution let isAdmin = true; isAdmin \u0026amp;\u0026amp; console.log(\u0026#34;Welcome admin!\u0026#34;); || - Dừng khi gặp truthy:\rfunction greet(name) { name = name || \u0026#34;Khách\u0026#34;; // Default value console.log(`Xin chào, ${name}!`); } greet(\u0026#34;John\u0026#34;); // \u0026#34;Xin chào, John!\u0026#34; greet(); // \u0026#34;Xin chào, Khách!\u0026#34; 6. So sánh với các toán tử\r== vs ===:\r// Loose equality (==) - Type coercion console.log(true == 1); // true console.log(false == 0); // true // Strict equality (===) - No type coercion console.log(true === 1); // false console.log(true === true); // true // Best practice: Always use === let isComplete = true; if (isComplete === true) { // ✅ Good console.log(\u0026#34;Task completed\u0026#34;); } 7. Bài tập nhỏ\rValidate form đăng ký:\nfunction validateUser(userData) { let email = userData.email || \u0026#34;\u0026#34;; let password = userData.password || \u0026#34;\u0026#34;; let age = userData.age || 0; let agreeTerms = userData.agreeTerms || false; let validEmail = email.includes(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.length \u0026gt;= 5; let validPassword = password.length \u0026gt;= 8; let validAge = age \u0026gt;= 13 \u0026amp;\u0026amp; age \u0026lt;= 120; let termsAccepted = agreeTerms === true; let isValid = validEmail \u0026amp;\u0026amp; validPassword \u0026amp;\u0026amp; validAge \u0026amp;\u0026amp; termsAccepted; return { isValid: isValid, checks: { validEmail, validPassword, validAge, termsAccepted } }; } let testUser = { email: \u0026#34;user@example.com\u0026#34;, password: \u0026#34;MyPass123\u0026#34;, age: 25, agreeTerms: true }; console.log(validateUser(testUser)); Chốt lại:\rBài 9 giúp bạn hiểu về kiểu dữ liệu Boolean với 2 giá trị true/false, Truthy/Falsy values, các toán tử logic (\u0026amp;\u0026amp;, ||, !), Short-circuit Evaluation, và sự khác biệt giữa == và === trong so sánh Boolean.\n📚 Bài tiếp theo\r👉 Bài 10: Null và Undefined - Tìm hiểu sự khác biệt giữa null và undefined trong JavaScript!\n","date":"2025-09-28T13:00:00+07:00","image":"https://img.youtube.com/vi/2Uvl-lJ9fBY/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-9-ki%E1%BB%83u-d%E1%BB%AF-li%E1%BB%87u-boolean-logic-%C4%91%C3%BAng/sai-trong-javascript/","title":"Bài 9 - Kiểu Dữ Liệu Boolean - Logic Đúng/Sai Trong JavaScript"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Null vs Undefined - Khái niệm\r// Undefined - hệ thống tự gán let notAssigned; console.log(notAssigned); // undefined // Null - lập trình viên gán có chủ ý let user = null; console.log(user); // null // So sánh console.log(typeof undefined); // \u0026#34;undefined\u0026#34; console.log(typeof null); // \u0026#34;object\u0026#34; (bug lịch sử!) console.log(undefined == null); // true console.log(undefined === null); // false 2. Khi nào xuất hiện?\rUndefined xuất hiện:\r// Biến chưa gán giá trị let notAssigned; console.log(notAssigned); // undefined // Truy cập property không tồn tại let obj = { name: \u0026#34;John\u0026#34; }; console.log(obj.age); // undefined // Function không return function noReturn() { let x = 5; } console.log(noReturn()); // undefined Null được gán có chủ ý:\r// Khởi tạo biến sẽ chứa object sau let user = null; // Reset giá trị object let data = { name: \u0026#34;John\u0026#34; }; data = null; // Xóa reference // API response không có dữ liệu function findUser(id) { return null; // Không tìm thấy } 3. Cách kiểm tra\rlet value1; let value2 = null; // Kiểm tra cụ thể console.log(value1 === undefined); // true console.log(value2 === null); // true // Kiểm tra cả hai console.log(value1 == null); // true console.log(value2 == null); // true // Nullish coalescing console.log(value1 ?? \u0026#34;default\u0026#34;); // \u0026#34;default\u0026#34; console.log(value2 ?? \u0026#34;default\u0026#34;); // \u0026#34;default\u0026#34; 4. Nullish Coalescing (??) vs Logical OR (||)\rlet userName = \u0026#34;\u0026#34;; let userAge = 0; let profile = null; // Nullish coalescing (??) - chỉ thay null/undefined console.log(userName ?? \u0026#34;Anonymous\u0026#34;); // \u0026#34;\u0026#34; (giữ nguyên) console.log(userAge ?? 18); // 0 (giữ nguyên) console.log(profile ?? {}); // {} (thay thế null) // Logical OR (||) - thay tất cả falsy values console.log(userName || \u0026#34;Anonymous\u0026#34;); // \u0026#34;Anonymous\u0026#34; console.log(userAge || 18); // 18 5. Best Practices\r// ✅ Good practices let user = null; // Sẽ chứa object sau let userList = []; // Mảng rỗng thay vì null let settings = {}; // Object rỗng thay vì null // Function với default parameters function createPost(title = \u0026#34;Untitled\u0026#34;, author = null) { return { title, author: author ?? \u0026#34;Anonymous\u0026#34;, createdAt: new Date() }; } // Check parameters function processUser(userData) { if (userData === null || userData === undefined) { throw new Error(\u0026#34;User data is required\u0026#34;); } return { id: userData.id, name: userData.name ?? \u0026#34;Unknown\u0026#34; }; } Chốt lại\rundefined: Hệ thống tự gán khi biến chưa có giá trị null: Lập trình viên gán có chủ ý để đại diện \u0026ldquo;không có đối tượng\u0026rdquo; Kiểm tra: === cho specific, == null cho cả hai Nullish coalescing (??): Chỉ thay thế null/undefined, giữ nguyên falsy values khác Best practice: Dùng null cho object, [] cho array, \u0026quot;\u0026quot; cho string 📚 Bài tiếp theo\r👉 Bài 11: Câu lệnh điều kiện if-else, switch-case - Học cách điều khiển luồng chương trình với các câu lệnh điều kiện!\n","date":"2025-09-28T13:30:00+07:00","image":"https://img.youtube.com/vi/CeM74bs91Sw/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-10-null-v%C3%A0-undefined-hi%E1%BB%83u-r%C3%B5-s%E1%BB%B1-kh%C3%A1c-bi%E1%BB%87t/","title":"Bài 10 - Null và Undefined - Hiểu Rõ Sự Khác Biệt"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Câu lệnh if\rlet age = 18; // If đơn giản if (age \u0026gt;= 18) { console.log(\u0026#34;Đủ tuổi!\u0026#34;); } // If với điều kiện phức tạp let hasLicense = true; if (age \u0026gt;= 18 \u0026amp;\u0026amp; hasLicense) { console.log(\u0026#34;Có thể lái xe!\u0026#34;); } 2. if-else statement\rlet score = 75; if (score \u0026gt;= 90) { console.log(\u0026#34;Xuất sắc - A\u0026#34;); } else if (score \u0026gt;= 80) { console.log(\u0026#34;Giỏi - B\u0026#34;); } else if (score \u0026gt;= 70) { console.log(\u0026#34;Khá - C\u0026#34;); } else if (score \u0026gt;= 60) { console.log(\u0026#34;Trung bình - D\u0026#34;); } else { console.log(\u0026#34;Yếu - F\u0026#34;); } // Phân loại thời gian let time = 14; if (time \u0026lt; 6) { console.log(\u0026#34;Đêm khuya\u0026#34;); } else if (time \u0026lt; 12) { console.log(\u0026#34;Buổi sáng\u0026#34;); } else if (time \u0026lt; 18) { console.log(\u0026#34;Buổi chiều\u0026#34;); } else { console.log(\u0026#34;Buổi tối\u0026#34;); } 3. switch-case statement\rlet dayOfWeek = 3; switch (dayOfWeek) { case 1: console.log(\u0026#34;Thứ hai\u0026#34;); break; case 2: console.log(\u0026#34;Thứ ba\u0026#34;); break; case 3: console.log(\u0026#34;Thứ tư\u0026#34;); break; default: console.log(\u0026#34;Ngày khác\u0026#34;); } // Fall-through behavior let month = 12; switch (month) { case 12: case 1: case 2: console.log(\u0026#34;Mùa đông\u0026#34;); break; case 3: case 4: case 5: console.log(\u0026#34;Mùa xuân\u0026#34;); break; default: console.log(\u0026#34;Mùa khác\u0026#34;); } // Switch với string let userRole = \u0026#34;admin\u0026#34;; switch (userRole) { case \u0026#34;admin\u0026#34;: console.log(\u0026#34;Quyền: Quản trị hệ thống\u0026#34;); break; case \u0026#34;editor\u0026#34;: console.log(\u0026#34;Quyền: Biên tập nội dung\u0026#34;); break; default: console.log(\u0026#34;Quyền: Không xác định\u0026#34;); } 4. Ternary Operator\rlet age = 20; // Cú pháp: condition ? valueIfTrue : valueIfFalse let message = age \u0026gt;= 18 ? \u0026#34;Người lớn\u0026#34; : \u0026#34;Trẻ em\u0026#34;; console.log(message); // \u0026#34;Người lớn\u0026#34; // Nested ternary let score = 85; let grade = score \u0026gt;= 90 ? \u0026#34;A\u0026#34; : score \u0026gt;= 80 ? \u0026#34;B\u0026#34; : score \u0026gt;= 70 ? \u0026#34;C\u0026#34; : \u0026#34;D\u0026#34;; // Trong template literals let user = { name: \u0026#34;John\u0026#34;, isOnline: true }; let status = `${user.name} ${user.isOnline ? \u0026#39;online\u0026#39; : \u0026#39;offline\u0026#39;}`; console.log(status); // \u0026#34;John online\u0026#34; Chốt lại\rif-else: Kiểm tra điều kiện true/false, dùng if-else if-else cho nhiều điều kiện switch-case: So sánh giá trị với nhiều trường hợp, nhớ break để tránh fall-through Ternary operator: condition ? true : false - ngắn gọn cho điều kiện đơn giản Best practices: Dùng === thay vì ==, luôn dùng {} cho block statement Validation: Kiểm tra input trước khi xử lý để tránh lỗi runtime 📚 Bài tiếp theo\r👉 Bài 12: Vòng lặp While - Học cách tạo vòng lặp với while và do-while!\n","date":"2025-09-28T14:00:00+07:00","image":"https://img.youtube.com/vi/g6AVmwqtnyw/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-11-c%C3%A2u-l%E1%BB%87nh-%C4%91i%E1%BB%81u-ki%E1%BB%87n-if-else-switch-case-%C4%91i%E1%BB%81u-khi%E1%BB%83n-lu%E1%BB%93ng/","title":"Bài 11 - Câu Lệnh Điều Kiện if-else, switch-case - Điều Khiển Luồng"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam ➰ Vòng lặp while là gì?\rVòng lặp while thực hiện lặp đi lặp lại một đoạn code khi điều kiện còn đúng:\n🔄 Kiểm tra điều kiện trước khi thực hiện ⏹️ Dừng khi điều kiện trở thành false ⚠️ Nguy hiểm: Có thể tạo vòng lặp vô tận nếu không cẩn thận 🎯 Phù hợp: Khi không biết trước số lần lặp 🔄 Cú pháp while loop\rCấu trúc cơ bản:\rwhile (condition) { // Code được thực hiện khi condition = true // Nhớ cập nhật condition để tránh vòng lặp vô tận } Ví dụ đơn giản:\rlet count = 1; while (count \u0026lt;= 5) { console.log(\u0026#34;Lần thứ\u0026#34;, count); count++; // Quan trọng: cập nhật count } console.log(\u0026#34;Kết thúc vòng lặp, count =\u0026#34;, count); // 6 Đếm ngược:\rlet countdown = 5; while (countdown \u0026gt; 0) { console.log(\u0026#34;Còn\u0026#34;, countdown, \u0026#34;giây...\u0026#34;); countdown--; } console.log(\u0026#34;🚀 Khởi động!\u0026#34;); ⚠️ Vòng lặp vô tận và cách tránh\rVí dụ vòng lặp vô tận (NGUY HIỂM!):\r// ❌ ĐỪNG CHẠY CODE NÀY! // let i = 1; // while (i \u0026lt;= 5) { // console.log(i); // // Quên cập nhật i → i luôn = 1 → vòng lặp vô tận // } // ❌ Các trường hợp khác // while (true) { // console.log(\u0026#34;Vô tận!\u0026#34;); // // Không có break hoặc cách thoát // } Cách tránh vòng lặp vô tận:\r// ✅ Luôn cập nhật biến điều kiện let i = 1; while (i \u0026lt;= 5) { console.log(i); i++; // QUAN TRỌNG! } // ✅ Hoặc dùng safety counter let attempts = 0; let maxAttempts = 1000; while (someCondition \u0026amp;\u0026amp; attempts \u0026lt; maxAttempts) { // Code logic attempts++; } if (attempts \u0026gt;= maxAttempts) { console.log(\u0026#34;Đã đạt giới hạn an toàn\u0026#34;); } 3. do-while loop\r// while - kiểm tra trước let x = 10; while (x \u0026lt; 5) { console.log(\u0026#34;while:\u0026#34;, x); // Không chạy vì 10 không \u0026lt; 5 x++; } // do-while - thực hiện trước, kiểm tra sau let y = 10; do { console.log(\u0026#34;do-while:\u0026#34;, y); // Chạy 1 lần: \u0026#34;do-while: 10\u0026#34; y++; } while (y \u0026lt; 5); // Ví dụ menu chương trình let choice; do { console.log(\u0026#34;=== MENU ===\u0026#34;); console.log(\u0026#34;1. Xem thông tin\u0026#34;); console.log(\u0026#34;2. Thoát\u0026#34;); choice = Math.floor(Math.random() * 3) + 1; // Giả lập input console.log(\u0026#34;Bạn chọn:\u0026#34;, choice); if (choice === 1) { console.log(\u0026#34;→ Hiển thị thông tin\u0026#34;); } else if (choice === 2) { console.log(\u0026#34;→ Thoát chương trình\u0026#34;); } } while (choice !== 2); 4. Ví dụ thực tế\r// Tìm kiếm trong mảng function findInArray(array, target) { let index = 0; while (index \u0026lt; array.length) { if (array[index] === target) { return { found: true, index: index }; } index++; } return { found: false, index: -1 }; } // Test let numbers = [5, 2, 8, 1, 9, 3]; let result = findInArray(numbers, 8); console.log(result); // { found: true, index: 2 } // Validation với while function getValidAge() { let age, attempts = 0; while (attempts \u0026lt; 3) { age = Number(prompt(\u0026#34;Nhập tuổi (0-150):\u0026#34;)); if (!isNaN(age) \u0026amp;\u0026amp; age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150) { return age; } attempts++; console.log(`Tuổi không hợp lệ. Còn ${3 - attempts} lần thử`); } return null; // Hết lượt thử } Chốt lại\rwhile loop: Kiểm tra điều kiện trước khi thực hiện, lặp khi điều kiện còn true do-while loop: Thực hiện ít nhất 1 lần, kiểm tra điều kiện sau Tránh vòng lặp vô tận: Luôn cập nhật biến điều kiện, dùng safety counter Use cases: Không biết trước số lần lặp, validation input, tìm kiếm dữ liệu Best practices: Test kỹ logic điều kiện, luôn có cách thoát khỏi loop 📚 Bài tiếp theo\r👉 Bài 13: Vòng lặp For - Tìm hiểu vòng lặp for và các biến thể của nó!\n","date":"2025-09-28T14:30:00+07:00","image":"https://img.youtube.com/vi/E4sUJ4LvYY0/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-12-v%C3%B2ng-l%E1%BA%B7p-while-l%E1%BA%B7p-khi-%C4%91i%E1%BB%81u-ki%E1%BB%87n-%C4%91%C3%BAng/","title":"Bài 12 - Vòng Lặp While - Lặp Khi Điều Kiện Đúng"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Vòng lặp for cơ bản\r// Cú pháp: for (initialization; condition; increment) for (let i = 1; i \u0026lt;= 5; i++) { console.log(i); } // Kết quả: 1, 2, 3, 4, 5 // Lặp qua mảng let fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;]; for (let i = 0; i \u0026lt; fruits.length; i++) { console.log(fruits[i]); } 2. Các biến thể\r// for...of - Lặp qua giá trị let colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;]; for (let color of colors) { console.log(color); } // for...in - Lặp qua key let person = { name: \u0026#34;John\u0026#34;, age: 30 }; for (let key in person) { console.log(key + \u0026#34;: \u0026#34; + person[key]); } // Vòng lặp lồng nhau for (let i = 1; i \u0026lt;= 3; i++) { for (let j = 1; j \u0026lt;= 3; j++) { console.log(i + \u0026#34; x \u0026#34; + j + \u0026#34; = \u0026#34; + i*j); } } 3. Ví dụ thực tế\r// Tính tổng các số trong mảng let numbers = [1, 2, 3, 4, 5]; let sum = 0; for (let i = 0; i \u0026lt; numbers.length; i++) { sum += numbers[i]; } console.log(\u0026#34;Tổng:\u0026#34;, sum); // 15 // Tìm số lớn nhất let scores = [85, 92, 78, 96, 88]; let max = scores[0]; for (let i = 1; i \u0026lt; scores.length; i++) { if (scores[i] \u0026gt; max) { max = scores[i]; } } console.log(\u0026#34;Điểm cao nhất:\u0026#34;, max); // 96 // Đếm số chẵn/lẻ let evenCount = 0, oddCount = 0; for (let num of numbers) { if (num % 2 === 0) { evenCount++; } else { oddCount++; } } console.log(\u0026#34;Chẵn:\u0026#34;, evenCount, \u0026#34;Lẻ:\u0026#34;, oddCount); Chốt lại\rfor loop: for (init; condition; increment) - biết trước số lần lặp for\u0026hellip;of: Lặp qua giá trị của arrays, strings for\u0026hellip;in: Lặp qua keys/properties của objects Nested loops: Vòng lặp lồng nhau cho ma trận 2D Best practices: Dùng for...of cho arrays, for...in cho objects 📚 Bài tiếp theo\r👉 Bài 14: Function trong JavaScript - Tìm hiểu về functions - Building blocks của JavaScript!\n","date":"2025-09-28T15:00:00+07:00","image":"https://img.youtube.com/vi/WUFb_huPvtI/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-13-v%C3%B2ng-l%E1%BA%B7p-for-l%E1%BA%B7p-v%E1%BB%9Bi-s%E1%BB%91-l%E1%BA%A7n-x%C3%A1c-%C4%91%E1%BB%8Bnh/","title":"Bài 13 - Vòng Lặp For - Lặp Với Số Lần Xác Định"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Function là gì?\rKhối lệnh có thể tái sử dụng nhiều lần. Thực hiện một nhiệm vụ cụ thể. Có thể nhận tham số (parameters) và trả về kết quả (return). 2. Cú pháp khai báo\r// Function thường function sayHello() { console.log(\u0026#34;Hello!\u0026#34;); } // Arrow function (ES6) const add = (a, b) =\u0026gt; a + b; 3. Tham số và Return\rCopy code function greet(name, age = 20) { return `Hi ${name}, ${age} tuổi!`; } greet(\u0026#34;An\u0026#34;); // \u0026#34;Hi An, 20 tuổi!\u0026#34; greet(\u0026#34;Bình\u0026#34;, 25); // \u0026#34;Hi Bình, 25 tuổi!\u0026#34; 4. Phạm vi biến (Scope)\rCopy code let global = \u0026#34;Biến toàn cục\u0026#34;; function demo() { let local = \u0026#34;Biến cục bộ\u0026#34;; console.log(global); // OK return local; } console.log(global); // OK console.log(local); // ❌ Lỗi 📚 Bài tiếp theo\rBài 15 - Mở rộng về Function\n","date":"2025-09-27T09:00:00+07:00","image":"https://img.youtube.com/vi/WUFb_huPvtI/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/javascript_bai14_function/","title":"Bài 14 - Function trong JavaScript"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Higher-order Function \u0026amp; Callback\r// Higher-order function: nhận function làm parameter function greet(name, callback) { console.log(\u0026#34;Xin chào, \u0026#34; + name); callback(); } function sayGoodbye() { console.log(\u0026#34;Tạm biệt!\u0026#34;); } greet(\u0026#34;An\u0026#34;, sayGoodbye); // Xin chào, An // Tạm biệt! 2. Array Methods với Callback\rlet numbers = [1, 2, 3, 4, 5]; // forEach - lặp qua mảng numbers.forEach(num =\u0026gt; console.log(num * 2)); // map - transform mảng let doubled = numbers.map(num =\u0026gt; num * 2); console.log(doubled); // [2, 4, 6, 8, 10] // filter - lọc mảng let evenNumbers = numbers.filter(num =\u0026gt; num % 2 === 0); console.log(evenNumbers); // [2, 4] // reduce - tính tổng let sum = numbers.reduce((total, num) =\u0026gt; total + num, 0); console.log(sum); // 15 3. Closure - Bao đóng\r// Function con truy cập biến function cha function outerFunction(x) { let outerVar = x; function innerFunction(y) { return outerVar + y; // Truy cập được outerVar } return innerFunction; } let addFive = outerFunction(5); console.log(addFive(3)); // 8 // Counter với closure function createCounter() { let count = 0; return function() { count++; return count; }; } let counter = createCounter(); console.log(counter()); // 1 console.log(counter()); // 2 4. Function Factory\r// Tạo functions với closure function createMultiplier(multiplier) { return function(x) { return x * multiplier; }; } let double = createMultiplier(2); let triple = createMultiplier(3); console.log(double(5)); // 10 console.log(triple(5)); // 15 // Greeter factory function createGreeter(greeting) { return function(name) { return greeting + \u0026#34;, \u0026#34; + name + \u0026#34;!\u0026#34;; }; } let sayHello = createGreeter(\u0026#34;Xin chào\u0026#34;); console.log(sayHello(\u0026#34;An\u0026#34;)); // Xin chào, An! Chốt lại\rHigher-order function: Nhận function làm parameter hoặc return function Callback: Function được truyền vào function khác để thực thi Array methods: forEach, map, filter, reduce - xử lý mảng hiệu quả Closure: Function con có thể truy cập biến của function cha Function factory: Sử dụng closure để tạo các function có behavior tương tự 📚 Bài tiếp theo\r👉 Bài 16: Đệ quy trong JavaScript - Kỹ thuật giải quyết vấn đề bằng chính nó!\n","date":"2025-09-28T15:30:00+07:00","image":"https://img.youtube.com/vi/pkuC_jsH1T8/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-15-function-n%C3%A2ng-cao-higher-order-callback/","title":"Bài 15 - Function Nâng Cao - Higher-order \u0026 Callback"},{"content":"🎥 Video hướng dẫn chi tiết\rNguồn: Khóa học JavaScript - Kteam 1. Đệ quy là gì?\r// Đệ quy: function gọi chính nó // Cần 2 thành phần: Base case + Recursive case function factorial(n) { // Base case - điều kiện dừng if (n \u0026lt;= 1) { return 1; } // Recursive case - gọi lại chính nó return n * factorial(n - 1); } console.log(factorial(5)); // 120 // 5! = 5 × 4 × 3 × 2 × 1 = 120 2. Ví dụ phổ biến\r// Fibonacci sequence function fibonacci(n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } console.log(fibonacci(6)); // 8 // Tìm kiếm nhị phân function binarySearch(arr, target, left = 0, right = arr.length - 1) { if (left \u0026gt; right) return -1; let mid = Math.floor((left + right) / 2); if (arr[mid] === target) return mid; if (arr[mid] \u0026gt; target) { return binarySearch(arr, target, left, mid - 1); } else { return binarySearch(arr, target, mid + 1, right); } } let numbers = [1, 3, 5, 7, 9]; console.log(binarySearch(numbers, 7)); // 3 3. Xử lý cấu trúc lồng nhau\r// Tính tổng mảng đa chiều function sumNestedArray(arr) { let sum = 0; for (let item of arr) { if (Array.isArray(item)) { sum += sumNestedArray(item); // Recursive } else { sum += item; // Base case } } return sum; } let nested = [1, [2, 3], [4, [5, 6]], 7]; console.log(sumNestedArray(nested)); // 28 // Flatten mảng function flattenArray(arr) { let result = []; for (let item of arr) { if (Array.isArray(item)) { result = result.concat(flattenArray(item)); } else { result.push(item); } } return result; } console.log(flattenArray(nested)); // [1, 2, 3, 4, 5, 6, 7] 4. Lưu ý quan trọng\r// ⚠️ Tránh Stack Overflow - luôn có base case function infiniteRecursion(n) { return infiniteRecursion(n); // NGUY HIỂM! } // ✅ So sánh với vòng lặp // Đệ quy - code ngắn gọn nhưng chậm hơn function factorialRecursive(n) { if (n \u0026lt;= 1) return 1; return n * factorialRecursive(n - 1); } // Vòng lặp - nhanh hơn, ít memory hơn function factorialIterative(n) { let result = 1; for (let i = 2; i \u0026lt;= n; i++) { result *= i; } return result; } Chốt lại\rĐệ quy: Function gọi chính nó, cần base case và recursive case Base case: Điều kiện dừng để tránh vòng lặp vô tận Ưu điểm: Code ngắn gọn, phù hợp với cấu trúc lồng nhau Nhược điểm: Chậm hơn vòng lặp, tiêu tốn memory, nguy cơ Stack Overflow Khi dùng: Cấu trúc đệ quy (tree, nested array), bài toán chia để trị 🎉 Chúc mừng!\rBạn đã hoàn thành 16 bài của series JavaScript Cơ Bản!\n🚀 Những gì bạn đã học:\nCài đặt NodeJS và chạy JavaScript Biến, hằng số và các kiểu dữ liệu Toán tử và template literals Cấu trúc điều khiển (if-else, switch, loops) Functions và higher-order functions Đệ quy và các thuật toán cơ bản ","date":"2025-09-28T16:00:00+07:00","image":"https://img.youtube.com/vi/LteNqj4DFD8/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-16-%C4%91%E1%BB%87-quy-trong-javascript-recursion/","title":"Bài 16 - Đệ Quy Trong JavaScript - Recursion"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Method Overloading\rCùng tên method, khác tham số Xảy ra trong cùng một class Compile-time polymorphism public class Calculator { // Cộng 2 số nguyên public int add(int a, int b) { return a + b; } // Cộng 3 số nguyên public int add(int a, int b, int c) { return a + b + c; } // Cộng 2 số thực public double add(double a, double b) { return a + b; } } 2) Method Overriding\rGhi đè method của class cha Cùng tên, cùng tham số Runtime polymorphism class Animal { public void makeSound() { System.out.println(\u0026#34;Some sound\u0026#34;); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } } class Cat extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Meow!\u0026#34;); } } 3) Quy tắc quan trọng\r3.1. Overloading Rules\rKhác số lượng tham số void print(int a) void print(int a, int b) Khác kiểu tham số void print(int a) void print(String a) Khác thứ tự tham số void print(int a, String b) void print(String b, int a) 3.2. Overriding Rules\rMethod phải có cùng tên và tham số Return type phải giống hoặc là subtype Access modifier không được hẹp hơn Không override static methods class Parent { public Number calculate() { return 0; } } class Child extends Parent { @Override public Integer calculate() { return 42; } // OK vì Integer extends Number } 4) So sánh Overloading vs Overriding\rOverloading\rCùng class Khác tham số Compile-time Không cần kế thừa Không dùng @Override Overriding\rClass cha-con Cùng tham số Runtime Cần kế thừa Dùng @Override 5) Best Practices\rOverloading\rĐặt tên method rõ ràng Không lạm dụng overload Tham số phải có ý nghĩa khác nhau Overriding\rLuôn dùng @Override Không thay đổi hành vi cốt lõi Gọi super khi cần Giữ nguyên contract của method ","date":"2025-09-22T21:00:00+07:00","image":"https://img.youtube.com/vi/F-3n_mzG4o8/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-12-override-v%C3%A0-overload-trong-java-kh%C3%A1c-nhau-th%E1%BA%BF-n%C3%A0o/","title":"Bài 12 - Override và Overload Trong Java - Khác Nhau Thế Nào?"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Array và ArrayList\r1.1. Array\r// Khai báo và khởi tạo int[] numbers = new int[5]; String[] names = {\u0026#34;John\u0026#34;, \u0026#34;Mary\u0026#34;, \u0026#34;Tom\u0026#34;}; // Truy cập phần tử numbers[0] = 10; String firstPerson = names[0]; 1.2. ArrayList\rArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Apple\u0026#34;); list.add(\u0026#34;Banana\u0026#34;); list.remove(0); System.out.println(list.get(0)); // Banana 2) List Interface\r// ArrayList - Truy cập nhanh List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); // LinkedList - Thêm/xóa nhanh List\u0026lt;Integer\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // Vector - Thread safe List\u0026lt;Integer\u0026gt; vector = new Vector\u0026lt;\u0026gt;(); 3) Set Interface\r// HashSet - Không cho phép trùng lặp Set\u0026lt;String\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); hashSet.add(\u0026#34;Apple\u0026#34;); hashSet.add(\u0026#34;Apple\u0026#34;); // Không thêm được // TreeSet - Sắp xếp tự động Set\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(5); treeSet.add(1); treeSet.add(3); System.out.println(treeSet); // [1, 3, 5] 4) Map Interface\r// HashMap Map\u0026lt;String, Integer\u0026gt; ages = new HashMap\u0026lt;\u0026gt;(); ages.put(\u0026#34;John\u0026#34;, 25); ages.put(\u0026#34;Mary\u0026#34;, 30); System.out.println(ages.get(\u0026#34;John\u0026#34;)); // 25 // TreeMap - Sắp xếp theo key Map\u0026lt;String, Double\u0026gt; scores = new TreeMap\u0026lt;\u0026gt;(); scores.put(\u0026#34;Math\u0026#34;, 8.5); scores.put(\u0026#34;English\u0026#34;, 7.0); 5) Các thao tác phổ biến\rList\u0026lt;String\u0026gt; fruits = new ArrayList\u0026lt;\u0026gt;(); // Thêm phần tử fruits.add(\u0026#34;Apple\u0026#34;); fruits.add(\u0026#34;Banana\u0026#34;); // Duyệt list for(String fruit : fruits) { System.out.println(fruit); } // Sử dụng Iterator Iterator\u0026lt;String\u0026gt; it = fruits.iterator(); while(it.hasNext()) { System.out.println(it.next()); } // Sắp xếp Collections.sort(fruits); // Tìm kiếm int index = fruits.indexOf(\u0026#34;Apple\u0026#34;); 6) So sánh hiệu năng\rArrayList: Truy cập nhanh, thêm/xóa chậm LinkedList: Truy cập chậm, thêm/xóa nhanh HashSet: Tìm kiếm nhanh O(1) TreeSet: Tìm kiếm O(log n), tự động sắp xếp HashMap: Tìm kiếm key nhanh O(1) TreeMap: Tìm kiếm key O(log n), key tự sắp xếp Tiếp theo: Override và Overload trong Java\r","date":"2025-09-22T20:00:00+07:00","image":"https://img.youtube.com/vi/m4QD2ykLiiw/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-11-collection-framework-trong-java-t%E1%BB%AB-array-%C4%91%E1%BA%BFn-arraylist/","title":"Bài 11 - Collection Framework Trong Java - Từ Array Đến ArrayList"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Exception là gì?\rLà sự kiện xảy ra trong quá trình thực thi chương trình làm gián đoạn luồng bình thường VD: NullPointerException, ArrayIndexOutOfBoundsException, FileNotFoundException\u0026hellip; 2) Try-catch cơ bản\rtry { int result = 10 / 0; // Ném ArithmeticException } catch (ArithmeticException e) { System.out.println(\u0026#34;Không thể chia cho 0\u0026#34;); } finally { System.out.println(\u0026#34;Luôn được thực thi\u0026#34;); } 3) Multiple catch blocks\rtry { int[] arr = new int[5]; arr[10] = 50; // ArrayIndexOutOfBoundsException int num = Integer.parseInt(\u0026#34;abc\u0026#34;); // NumberFormatException } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\u0026#34;Lỗi truy cập mảng\u0026#34;); } catch (NumberFormatException e) { System.out.println(\u0026#34;Lỗi chuyển đổi số\u0026#34;); } catch (Exception e) { // Bắt tất cả exception khác System.out.println(\u0026#34;Lỗi: \u0026#34; + e.getMessage()); } 4) Throw và Throws\rpublic class AgeValidator { public static void validateAge(int age) throws IllegalArgumentException { if (age \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Tuổi không được âm\u0026#34;); } if (age \u0026gt; 150) { throw new IllegalArgumentException(\u0026#34;Tuổi không hợp lệ\u0026#34;); } } public static void main(String[] args) { try { validateAge(-5); } catch (IllegalArgumentException e) { System.out.println(\u0026#34;Lỗi: \u0026#34; + e.getMessage()); } } } 5) Custom Exception\rclass InsufficientBalanceException extends Exception { public InsufficientBalanceException(String message) { super(message); } } class BankAccount { private double balance; public void withdraw(double amount) throws InsufficientBalanceException { if (amount \u0026gt; balance) { throw new InsufficientBalanceException(\u0026#34;Số dư không đủ\u0026#34;); } balance -= amount; } } 6) Best Practices\rLuôn xử lý các exception cụ thể trước Exception chung Đóng tài nguyên trong finally hoặc dùng try-with-resources Log exception đầy đủ trong production Tránh catch exception mà không xử lý Tạo custom exception có ý nghĩa Tiếp theo: Collection trong Java\r","date":"2025-09-22T19:00:00+07:00","image":"https://img.youtube.com/vi/EVoMK9Yo0fY/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-10-exception-trong-java-x%E1%BB%AD-l%C3%BD-ngo%E1%BA%A1i-l%E1%BB%87-chuy%C3%AAn-nghi%E1%BB%87p/","title":"Bài 10 - Exception Trong Java - Xử Lý Ngoại Lệ Chuyên Nghiệp"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Interface là gì?\rLà bản thiết kế cho class, định nghĩa các hành vi mà class phải thực hiện Chỉ chứa abstract methods và constants Class implement interface phải override tất cả methods 2) Cách khai báo và sử dụng\rpublic interface Animal { // Constants (mặc định là public static final) String TYPE = \u0026#34;Animal\u0026#34;; // Abstract methods (mặc định là public abstract) void makeSound(); void move(); } class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } @Override public void move() { System.out.println(\u0026#34;Running on 4 legs\u0026#34;); } } 3) Tại sao cần Interface?\rĐạt được 100% abstraction Hỗ trợ multiple inheritance Loose coupling (giảm sự phụ thuộc giữa các class) // Một class có thể implement nhiều interface public class Bird implements Flyable, Walkable { @Override public void fly() { System.out.println(\u0026#34;Flying...\u0026#34;); } @Override public void walk() { System.out.println(\u0026#34;Walking...\u0026#34;); } } 4) Default Methods (Java 8+)\rpublic interface Vehicle { void start(); // Default method có implementation default void stop() { System.out.println(\u0026#34;Vehicle stopping...\u0026#34;); } } Tiếp theo: Xử lý ngoại lệ trong Java\r","date":"2025-09-22T18:00:00+07:00","image":"https://img.youtube.com/vi/RbhNslWAQHo/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-9-interface-trong-java-b%E1%BA%AFt-bu%E1%BB%99c-ph%E1%BA%A3i-hi%E1%BB%83u/","title":"Bài 9 - Interface Trong Java - Bắt Buộc Phải Hiểu"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Abstract Class là gì?\rLà class được khai báo với từ khóa abstract Không thể tạo instance trực tiếp từ abstract class Có thể chứa cả abstract method và method thường Được dùng làm base class cho các class khác 2) Abstract Method\rMethod được khai báo nhưng không có implementation Các class con phải override tất cả abstract methods public abstract class Animal { // Abstract method - không có implementation public abstract void makeSound(); // Method thường - có implementation public void eat() { System.out.println(\u0026#34;Eating...\u0026#34;); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } } 3) Đặc điểm của Abstract Class\r3.1. Không thể tạo instance\r// Sai - không thể tạo instance Animal animal = new Animal(); // Đúng - tạo instance từ class con Animal animal = new Dog(); 3.2. Có thể có constructor\rpublic abstract class Shape { private String color; // Constructor trong abstract class public Shape(String color) { this.color = color; } public abstract double calculateArea(); } class Circle extends Shape { private double radius; public Circle(String color, double radius) { super(color); // Gọi constructor của abstract class this.radius = radius; } @Override public double calculateArea() { return Math.PI * radius * radius; } } 3.3. Có thể có fields và methods thường\rpublic abstract class Database { protected String connectionString; // Method thường public void connect() { System.out.println(\u0026#34;Connecting to \u0026#34; + connectionString); } // Abstract method public abstract void query(); } 4) Khi nào dùng Abstract Class?\r4.1. Template Method Pattern\rpublic abstract class Game { // Template method public final void play() { initialize(); startPlay(); endPlay(); } // Hooks abstract void initialize(); abstract void startPlay(); abstract void endPlay(); } 4.2. Common Base Functionality\rpublic abstract class Vehicle { protected String brand; protected String model; public String getInfo() { return brand + \u0026#34; \u0026#34; + model; } abstract void start(); } 5) Abstract Class vs Interface\rAbstract Class\rCó thể có fields không static và non-final Có thể có method implementation Một class chỉ extend được một abstract class Có thể có constructor Access modifiers đa dạng Interface\rFields luôn là static và final Methods mặc định là abstract (Java 8+ có default methods) Một class có thể implement nhiều interface Không có constructor Methods luôn là public 6) Best Practices\r6.1. Sử dụng Template Method Pattern\rpublic abstract class DataMiner { public final void mine() { openFile(); extractData(); parseData(); closeFile(); } abstract void extractData(); abstract void parseData(); } 6.2. Cung cấp implementation mặc định\rpublic abstract class Logger { // Default implementation public void log(String message) { System.out.println(\u0026#34;Default: \u0026#34; + message); } // Must be implemented abstract void logError(String error); } 7) Kết luận \u0026amp; cảm nhận\rAbstract class là công cụ mạnh mẽ cho code tái sử dụng Kết hợp tốt với Template Method Pattern Cần cân nhắc giữa abstract class và interface Tiếp theo: Interface trong Java\r","date":"2025-09-22T17:00:00+07:00","image":"https://img.youtube.com/vi/Hbp2zLIqmak/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-8-abstract-class-trong-java-qu%C3%A1-chi-l%C3%A0-tr%E1%BB%ABu-t%C6%B0%E1%BB%A3ng/","title":"Bài 8 - Abstract Class Trong Java - Quá Chi Là TRỪU TƯỢNG"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Đa hình là gì?\rĐa hình (Polymorphism) cho phép một đối tượng có nhiều \u0026ldquo;hình dạng\u0026rdquo; khác nhau:\nMột method có thể có nhiều cách thực hiện Một đối tượng có thể được xem như nhiều kiểu khác nhau 2) Compile-time Polymorphism (Method Overloading)\rpublic class Calculator { // Cùng tên method, khác tham số public int add(int a, int b) { return a + b; } public double add(double a, double b) { return a + b; } public int add(int a, int b, int c) { return a + b + c; } } 3) Runtime Polymorphism (Method Overriding)\rclass Animal { public void makeSound() { System.out.println(\u0026#34;Some sound\u0026#34;); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } } class Cat extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Meow!\u0026#34;); } } // Sử dụng Animal animal1 = new Dog(); // Đa hình Animal animal2 = new Cat(); // Đa hình animal1.makeSound(); // \u0026#34;Woof!\u0026#34; animal2.makeSound(); // \u0026#34;Meow!\u0026#34; 4) Upcasting \u0026amp; Downcasting\r4.1. Upcasting\rChuyển đổi từ class con lên class cha (tự động)\nDog dog = new Dog(); Animal animal = dog; // Upcasting 4.2. Downcasting\rChuyển đổi từ class cha xuống class con (cần kiểm tra)\nAnimal animal = new Dog(); if (animal instanceof Dog) { Dog dog = (Dog) animal; // Downcasting dog.bark(); } 5) Đa hình với Interface\rinterface Playable { void play(); } class Guitar implements Playable { @Override public void play() { System.out.println(\u0026#34;Playing guitar...\u0026#34;); } } class Piano implements Playable { @Override public void play() { System.out.println(\u0026#34;Playing piano...\u0026#34;); } } // Sử dụng Playable instrument1 = new Guitar(); Playable instrument2 = new Piano(); instrument1.play(); // \u0026#34;Playing guitar...\u0026#34; instrument2.play(); // \u0026#34;Playing piano...\u0026#34; 6) Best Practices\r6.1. Programming to Interface\r// Thay vì ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // Nên dùng List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 6.2. Sử dụng @Override\r@Override // Giúp compiler kiểm tra public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } 6.3. Kiểm tra type trước khi cast\rif (obj instanceof Dog) { Dog dog = (Dog) obj; } else { // Xử lý trường hợp khác } 7) Kết luận \u0026amp; cảm nhận\rĐa hình giúp code linh hoạt, dễ mở rộng Kết hợp với interface tạo code loosely coupled Cẩn thận với downcasting để tránh lỗi runtime Tiếp theo: Abstract Class trong Java\r","date":"2025-09-22T16:30:00+07:00","image":"https://img.youtube.com/vi/OfEYrSBovtw/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-7-t%C3%ADnh-%C4%91a-h%C3%ACnh-polymorphism-trong-java/","title":"Bài 7 - Tính Đa Hình (Polymorphism) Trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Tính đóng gói là gì?\rĐóng gói (Encapsulation) là việc:\nGói dữ liệu và phương thức xử lý vào một đơn vị (class) Giấu chi tiết triển khai, chỉ công khai những gì cần thiết Kiểm soát quyền truy cập vào dữ liệu thông qua các method 2) Access Modifiers trong Java\r2.1. private\rChỉ truy cập được trong cùng class public class BankAccount { private double balance; // Chỉ truy cập trong class private void updateBalance(double amount) { balance += amount; } } 2.2. protected\rTruy cập được trong cùng package và các class con public class Animal { protected String name; // Truy cập trong package và class con } class Dog extends Animal { void setName(String newName) { name = newName; // OK vì là class con } } 2.3. public\rTruy cập được từ mọi nơi public class User { public String username; // Không nên public trực tiếp public void login() { // Method công khai System.out.println(\u0026#34;Logging in...\u0026#34;); } } 2.4. default (package-private)\rTruy cập được trong cùng package class Helper { // Không có modifier = default void helperMethod() { // Chỉ dùng trong package } } 3) Getter và Setter\rKiểm soát truy cập thông qua method:\npublic class Student { private String name; private int age; // Getter public String getName() { return name; } // Setter với validation public void setAge(int age) { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { this.age = age; } else { throw new IllegalArgumentException(\u0026#34;Invalid age\u0026#34;); } } } 4) Lợi ích của đóng gói\rBảo mật dữ liệu\nNgăn truy cập trực tiếp Kiểm soát thông qua method Linh hoạt trong thay đổi\npublic class User { private String name; // Có thể thay đổi cách lưu name mà không ảnh hưởng code bên ngoài public String getName() { return name.toUpperCase(); // Thêm xử lý } } Dễ bảo trì\nCode gọn gàng, có tổ chức Dễ debug và sửa lỗi 5) Best Practices\r5.1. Luôn đóng gói dữ liệu\r// Không tốt public class Bad { public String data; } // Tốt public class Good { private String data; public String getData() { return data; } } 5.2. Validation trong setter\rpublic void setPassword(String password) { if (password == null || password.length() \u0026lt; 6) { throw new IllegalArgumentException(\u0026#34;Invalid password\u0026#34;); } this.password = password; } 5.3. Immutable khi có thể\rpublic final class ImmutablePoint { private final int x; private final int y; public ImmutablePoint(int x, int y) { this.x = x; this.y = y; } // Chỉ có getter, không có setter public int getX() { return x; } public int getY() { return y; } } 6) Kết luận \u0026amp; cảm nhận\rĐóng gói là nền tảng cho code an toàn, dễ bảo trì Luôn cân nhắc access level phù hợp cho từng thành phần Getter/Setter không chỉ là boilerplate code mà còn là cơ chế bảo vệ dữ liệu Tiếp theo: Tính Đa Hình trong Java\r","date":"2025-09-22T16:00:00+07:00","image":"https://img.youtube.com/vi/rTVk4mPyenE/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-6-t%C3%ADnh-%C4%91%C3%B3ng-g%C3%B3i-encapsulation-vs-hackers/","title":"Bài 6 - Tính Đóng Gói (Encapsulation) vs Hackers"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Kế thừa là gì?\rKế thừa là cơ chế cho phép một class (subclass) kế thừa các thuộc tính và phương thức từ một class khác (superclass).\n2) Cú pháp kế thừa\rclass Animal { protected String name; public void eat() { System.out.println(name + \u0026#34; is eating\u0026#34;); } } class Dog extends Animal { public void bark() { System.out.println(name + \u0026#34; says: Woof!\u0026#34;); } } 3) Các loại kế thừa\r3.1. Single Inheritance\rMột class kế thừa từ một class duy nhất.\nclass A {} class B extends A {} 3.2. Multilevel Inheritance\rKế thừa nhiều cấp.\nclass Animal {} class Mammal extends Animal {} class Dog extends Mammal {} 3.3. Hierarchical Inheritance\rNhiều class cùng kế thừa từ một class.\nclass Animal {} class Dog extends Animal {} class Cat extends Animal {} 4) Method Overriding\rCon có thể ghi đè phương thức của cha.\nclass Animal { public void makeSound() { System.out.println(\u0026#34;Some sound\u0026#34;); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } } 5) Từ khóa final\rNgăn kế thừa: final class Ngăn override: final method final class Constants { // Không thể kế thừa từ class này } class Animal { final void breathe() { // Không thể override phương thức này } } 6) Best Practices\r6.1. Composition over Inheritance\rƯu tiên dùng composition khi có thể.\n// Inheritance class ElectricCar extends Car {} // Composition (better) class Car { private Engine engine; } 6.2. Programming to Interface\r// Instead of Dog dog = new Dog(); // Better Animal dog = new Dog(); 6.3. Liskov Substitution Principle\rClass con phải có thể thay thế class cha mà không gây lỗi.\n7) Những điều cần tránh\rKế thừa quá nhiều tầng Override method mà không giữ đúng tính chất của lớp cha Lạm dụng kế thừa khi không cần thiết 8) Kết luận \u0026amp; cảm nhận\rKế thừa là công cụ mạnh mẽ nhưng cần dùng đúng chỗ Ưu tiên composition trong nhiều trường hợp Tuân thủ SOLID principles khi thiết kế kế thừa Tiếp theo: Tính Đóng Gói trong Java\r","date":"2025-09-22T15:30:00+07:00","image":"https://img.youtube.com/vi/8h42m579ez4/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-5-th%E1%BB%91ng-tr%E1%BB%8B-t%C3%ADnh-k%E1%BA%BF-th%E1%BB%ABa-inheritance-trong-java/","title":"Bài 5 - Thống Trị Tính Kế Thừa (Inheritance) Trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) OOP là gì?\rLập trình hướng đối tượng (Object-Oriented Programming) là phương pháp lập trình:\nXem mọi thứ như đối tượng (object) Mỗi đối tượng có thuộc tính (attributes) và hành vi (methods) Code được tổ chức thành các class có tính độc lập 2) 4 Trụ cột của OOP\r2.1. Tính đóng gói (Encapsulation)\rGói dữ liệu và phương thức xử lý vào một đơn vị Che giấu chi tiết bên trong, chỉ công khai những gì cần thiết public class BankAccount { private double balance; // Thuộc tính private public void deposit(double amount) { // Method public if (amount \u0026gt; 0) { balance += amount; } } } 2.2. Tính kế thừa (Inheritance)\rClass con kế thừa thuộc tính và phương thức từ class cha Tái sử dụng và mở rộng code class Animal { protected String name; public void eat() { System.out.println(\u0026#34;Eating...\u0026#34;); } } class Dog extends Animal { public void bark() { System.out.println(\u0026#34;Woof!\u0026#34;); } } 2.3. Tính đa hình (Polymorphism)\rMột hành động có thể thực hiện theo nhiều cách khác nhau Overriding và Overloading class Animal { public void makeSound() { System.out.println(\u0026#34;Some sound\u0026#34;); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Woof!\u0026#34;); } } class Cat extends Animal { @Override public void makeSound() { System.out.println(\u0026#34;Meow!\u0026#34;); } } 2.4. Tính trừu tượng (Abstraction)\rẨn chi tiết phức tạp, chỉ hiển thị tính năng cần thiết Sử dụng abstract class và interface abstract class Shape { abstract double calculateArea(); } class Circle extends Shape { private double radius; @Override double calculateArea() { return Math.PI * radius * radius; } } 3) Ưu điểm của OOP\rCode có tổ chức, dễ bảo trì Tái sử dụng code hiệu quả Bảo mật tốt hơn nhờ tính đóng gói Linh hoạt trong phát triển nhờ tính đa hình Mô phỏng thực tế tốt hơn 4) Best Practices trong OOP\rTuân thủ nguyên tắc SOLID Ưu tiên composition over inheritance Program to interface, not implementation Keep classes small and focused Đặt tên class, method có ý nghĩa 5) Kết luận \u0026amp; cảm nhận\rOOP giúp tổ chức code theo cách tự nhiên, dễ hiểu 4 trụ cột OOP là nền tảng cho thiết kế phần mềm tốt Cần thời gian thực hành để nắm vững và áp dụng hiệu quả Tiếp theo: Tính Kế thừa trong Java\r","date":"2025-09-22T15:00:00+07:00","image":"https://img.youtube.com/vi/IcYpk-Kf4Fo/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-4-l%E1%BA%ADp-tr%C3%ACnh-h%C6%B0%E1%BB%9Bng-%C4%91%E1%BB%91i-t%C6%B0%E1%BB%A3ng-oop-trong-java/","title":"Bài 4 - Lập Trình Hướng Đối Tượng (OOP) trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Từ khóa super là gì?\rsuper dùng để tham chiếu đến lớp cha (superclass), cho phép:\nGọi constructor của lớp cha Gọi method của lớp cha Truy cập thuộc tính của lớp cha 2) Gọi constructor lớp cha\rclass Animal { private String type; public Animal(String type) { this.type = type; } } class Dog extends Animal { private String name; public Dog(String name) { super(\u0026#34;Dog\u0026#34;); // Gọi constructor lớp Animal this.name = name; } } 3) Gọi method lớp cha khi override\rclass Animal { public void makeSound() { System.out.println(\u0026#34;Some sound\u0026#34;); } } class Dog extends Animal { @Override public void makeSound() { super.makeSound(); // Gọi method của lớp cha System.out.println(\u0026#34;Woof!\u0026#34;); } } 4) Truy cập thuộc tính lớp cha\rclass Animal { protected String type; public Animal(String type) { this.type = type; } } class Dog extends Animal { private String name; public Dog(String name) { super(\u0026#34;Dog\u0026#34;); this.name = name; } public void printInfo() { System.out.println(\u0026#34;Type: \u0026#34; + super.type); // Truy cập biến lớp cha System.out.println(\u0026#34;Name: \u0026#34; + this.name); } } 5) Super với Constructor Chaining\rclass Animal { protected String type; protected String color; public Animal(String type) { this(type, \u0026#34;Unknown\u0026#34;); // Constructor chaining trong lớp cha } public Animal(String type, String color) { this.type = type; this.color = color; } } class Dog extends Animal { private String name; public Dog(String name) { super(\u0026#34;Dog\u0026#34;); // Gọi constructor 1 tham số của Animal this.name = name; } public Dog(String name, String color) { super(\u0026#34;Dog\u0026#34;, color); // Gọi constructor 2 tham số của Animal this.name = name; } } 6) Khi nào dùng super?\rPHẢI dùng khi override constructor của lớp cha Khi muốn gọi method gốc từ lớp cha sau khi override Khi cần truy cập thuộc tính của lớp cha bị che bởi lớp con 7) Kết luận \u0026amp; cảm nhận\rsuper là công cụ quan trọng trong kế thừa Giúp tận dụng code của lớp cha một cách hiệu quả Cần hiểu rõ để tránh lỗi khi override Tiếp theo: Lập trình hướng đối tượng trong Java\r","date":"2025-09-22T14:30:00+07:00","image":"https://img.youtube.com/vi/mmgmrG6G-lI/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-3-thay-%C4%91%E1%BB%95i-suy-ngh%C4%A9-v%E1%BB%81-super-trong-java/","title":"Bài 3 - Thay đổi suy nghĩ về SUPER trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Từ khóa this là gì?\rthis đại diện cho đối tượng hiện tại của class, dùng để:\nPhân biệt biến instance và tham số Gọi constructor khác Trả về instance hiện tại 2) Phân biệt biến instance và tham số\rpublic class Student { private String name; // biến instance public Student(String name) { // tham số this.name = name; // this.name là biến instance } } 3) Gọi constructor khác (Constructor Chaining)\rpublic class Student { private String name; private int age; public Student() { this(\u0026#34;No Name\u0026#34;, 0); // Gọi constructor có 2 tham số } public Student(String name, int age) { this.name = name; this.age = age; } } 4) Method Chaining với this\rTrả về instance hiện tại để cho phép gọi nhiều method liên tiếp.\npublic class StringBuilder { private String str; public StringBuilder append(String s) { str += s; return this; // Trả về đối tượng hiện tại } // Có thể gọi liên tiếp StringBuilder sb = new StringBuilder() .append(\u0026#34;Hello\u0026#34;) .append(\u0026#34; \u0026#34;) .append(\u0026#34;World\u0026#34;); } 5) This trong inner class\rPhân biệt đối tượng của outer class và inner class.\npublic class OuterClass { private int x = 10; class InnerClass { private int x = 20; public void printX() { System.out.println(\u0026#34;Inner x: \u0026#34; + this.x); // 20 System.out.println(\u0026#34;Outer x: \u0026#34; + OuterClass.this.x); // 10 } } } 6) Khi nào dùng this?\rKhi có trùng tên biến instance và tham số Muốn gọi constructor khác trong cùng class Cần trả về instance hiện tại (method chaining) Truy cập từ inner class ra outer class 7) Kết luận \u0026amp; cảm nhận\rthis giúp code rõ ràng, tránh nhầm lẫn khi đặt tên Method chaining với this giúp code ngắn gọn, dễ đọc Hiểu về this là nền tảng cho nhiều design pattern Tiếp theo: Từ khóa SUPER trong Java\r","date":"2025-09-22T14:00:00+07:00","image":"https://img.youtube.com/vi/yvDICGATFDc/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-2-s%E1%BB%AD-d%E1%BB%A5ng-this-trong-java-%C4%91%E1%BB%83-code-ngon-h%C6%A1n/","title":"Bài 2 - Sử dụng THIS trong Java để code ngon hơn"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Constructor Chaining\rGọi constructor này từ constructor khác trong cùng class.\npublic class Student { private String name; private int age; private String address; public Student() { this(\u0026#34;No Name\u0026#34;, 0); // Gọi constructor 2 tham số } public Student(String name, int age) { this(name, age, \u0026#34;Unknown\u0026#34;); // Gọi constructor 3 tham số } public Student(String name, int age, String address) { this.name = name; this.age = age; this.address = address; } } 2) Copy Constructor\rTạo đối tượng mới bằng cách copy từ đối tượng có sẵn.\npublic class Point { private int x, y; public Point(int x, int y) { this.x = x; this.y = y; } // Copy constructor public Point(Point p) { this.x = p.x; this.y = p.y; } } Point p1 = new Point(10, 20); Point p2 = new Point(p1); // Copy values từ p1 3) Private Constructor\rHạn chế tạo đối tượng, thường dùng trong Singleton Pattern.\npublic class DatabaseConnection { private static DatabaseConnection instance; private DatabaseConnection() { // Private constructor } public static DatabaseConnection getInstance() { if (instance == null) { instance = new DatabaseConnection(); } return instance; } } 4) Constructor với Inheritance\rConstructor của lớp cha luôn được gọi trước khi khởi tạo lớp con.\nclass Animal { private String type; public Animal(String type) { this.type = type; } } class Dog extends Animal { private String name; public Dog(String name) { super(\u0026#34;Dog\u0026#34;); // Phải gọi constructor lớp cha this.name = name; } } 5) Kết luận \u0026amp; cảm nhận\rConstructor chaining giúp code gọn gàng, tái sử dụng logic khởi tạo Copy constructor an toàn khi cần nhân bản đối tượng Private constructor là kỹ thuật quan trọng trong design pattern Tiếp theo: Từ khóa this trong Java\r","date":"2025-09-22T13:30:00+07:00","image":"https://img.youtube.com/vi/NqfY0cQQrhA/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-1-b%C3%AD-k%C3%ADp-constructor-n%C3%A2ng-cao-trong-java/","title":"Bài 1 - Bí Kíp Constructor Nâng Cao Trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) String là immutable - bất biến\rString trong Java là bất biến (immutable) - nghĩa là không thể thay đổi sau khi tạo.\nString s1 = \u0026#34;Hello\u0026#34;; s1.concat(\u0026#34; World\u0026#34;); // Tạo string mới nhưng không gán lại System.out.println(s1); // Vẫn in \u0026#34;Hello\u0026#34; // Phải gán kết quả vào biến mới String s2 = s1.concat(\u0026#34; World\u0026#34;); System.out.println(s2); // In \u0026#34;Hello World\u0026#34; 2) String Pool\rJava sử dụng String Pool để tối ưu bộ nhớ, tái sử dụng string giống nhau.\nString str1 = \u0026#34;Java\u0026#34;; String str2 = \u0026#34;Java\u0026#34;; // Trỏ cùng về 1 vị trí trong pool System.out.println(str1 == str2); // true String str3 = new String(\u0026#34;Java\u0026#34;); // Tạo đối tượng mới System.out.println(str1 == str3); // false 3) So sánh String đúng cách\rDo cơ chế String Pool, không nên dùng == để so sánh String.\nString a = \u0026#34;Code\u0026#34;; String b = new String(\u0026#34;Code\u0026#34;); System.out.println(a == b); // false System.out.println(a.equals(b)); // true - cách đúng 4) Hiệu suất với String\rKhi cần nối nhiều String, dùng StringBuilder thay vì toán tử +.\n// Không hiệu quả String result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; 1000; i++) { result += i; // Tạo nhiều đối tượng String mới } // Hiệu quả hơn StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { sb.append(i); // Thay đổi trực tiếp nội dung } String result = sb.toString(); 5) Kết luận \u0026amp; cảm nhận\rString bất biến giúp code an toàn hơn, tránh thay đổi nội dung không mong muốn Hiểu về String Pool giúp tối ưu bộ nhớ và viết code so sánh chính xác StringBuilder là giải pháp hiệu quả khi cần thao tác String nhiều lần Tiếp theo: Constructor nâng cao trong Java\r","date":"2025-09-22T13:00:00+07:00","image":"https://img.youtube.com/vi/AQzJAA994OE/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-9-string-b%E1%BA%A5t-bi%E1%BA%BFn-immutable-trong-java/","title":"Bài 9 - String Bất Biến (Immutable) trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Enum là gì?\rEnum là kiểu dữ liệu liệt kê, chứa các hằng số cố định, thường dùng đại diện nhóm giá trị ràng buộc.\nenum Day { MON, TUE, WED, THU, FRI, SAT, SUN } Day today = Day.SAT; System.out.println(today); // SAT Duyệt enum:\nfor (Day d : Day.values()) { System.out.println(d); } 2) Wrapper Class\rLớp bao (Wrapper) như Integer, Double, Boolean\u0026hellip; giúp dùng các kiểu dữ liệu nguyên thủy như đối tượng.\nint x = 5; Integer xx = x; System.out.println(xx.compareTo(8)); // -1 Dùng Wrapper khi làm việc với collections/ArrayList (chỉ nhận object).\n3) Khi nào dùng Enum, Wrapper?\rEnum: dùng cho nhóm giá trị giới hạn (trạng thái, ngày trong tuần, loại đơn hàng\u0026hellip;). Wrapper: cần tính năng object với giá trị số/nguyên thủy, truyền qua API/library. 4) Kết luận \u0026amp; cảm nhận\rVideo Code Thủ giúp mình hiểu, tận dụng enum cho code rõ ràng, giảm bug vì giá trị sai lệch.\nWrapper class cực kỳ hữu ích khi thao tác collection, sử dụng phương thức tiện ích của lớp đối tượng.\nTiếp theo: Bài 9 – Exception Handling\r","date":"2025-09-22T12:30:00+07:00","image":"https://img.youtube.com/vi/vKvBz238wfg/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-8-enum-v%C3%A0-wrapper-class-trong-java/","title":"Bài 8 - Enum và Wrapper Class trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) HashMap – Lưu trữ dạng ánh xạ (key/value)\rCấu trúc lưu dữ liệu dạng cặp khóa (key) – giá trị (value), cho phép tra cứu nhanh dựa trên key.\nimport java.util.HashMap; HashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;An\u0026#34;, 18); map.put(\u0026#34;Nam\u0026#34;, 20); System.out.println(map.get(\u0026#34;An\u0026#34;)); // 18 2) Set và HashSet – Tập hợp không trùng lặp\rSet không cho phép phần tử lặp lại, xếp theo thứ tự phụ thuộc vào triển khai (HashSet mất thứ tự).\nimport java.util.HashSet; HashSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;Java\u0026#34;); set.add(\u0026#34;Code Thủ\u0026#34;); set.add(\u0026#34;Java\u0026#34;); // không thêm lại! System.out.println(set.size()); // 2 3) Khi nào dùng Map, HashSet?\rHashMap dùng khi cần tra cứu theo khóa. Set dùng khi muốn loại bỏ dữ liệu trùng. Kết hợp lọc dữ liệu với tập hợp lớn. 4) Kết luận \u0026amp; cảm nhận\rNhờ video Code Thủ, mình làm chủ cách chọn cấu trúc lưu trữ phù hợp, tiết kiệm thời gian dựng thuật toán xử lý dữ liệu lớn.\nLưu ý: Khi thao tác với Map/Set nên thử in ra nhiều trường hợp edge case!\nTiếp theo: Bài 8 – Enum và Wrapper Class\r","date":"2025-09-22T12:00:00+07:00","image":"https://img.youtube.com/vi/TEDZbOH0Y0o/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-7-hashmap-set-v%C3%A0-hashset-trong-java/","title":"Bài 7 - HashMap, Set và HashSet trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Mảng (Array) là gì?\rMảng lưu nhiều giá trị cùng kiểu, truy xuất bằng chỉ số.\nSố phần tử mảng được cố định khi khởi tạo.\nint[] nums = new int[3]; nums[0] = 10; nums[1] = 20; nums[2] = 30; System.out.println(nums[1]); // 20 Khởi tạo nhanh:\nString[] names = {\u0026#34;An\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;Chi\u0026#34;}; 2) Duyệt mảng\rfor (int i = 0; i \u0026lt; nums.length; i++) { System.out.println(nums[i]); } 3) Giới thiệu ArrayList\rKết cấu động (co giãn tự động, có thể thêm/xóa phần tử linh hoạt).\nimport java.util.ArrayList; ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;Code Thủ\u0026#34;); System.out.println(list.get(1)); // Code Thủ Duyệt ArrayList:\nfor (String item : list) { System.out.println(item); } 4) So sánh array vs ArrayList\rTiêu chí Array ArrayList Kích thước Cố định Linh hoạt Kiểu dữ liệu Phải xác định cụ thể Có thể dùng object Tăng/giảm Không Dùng add/remove 5) Kết luận \u0026amp; cảm nhận\rVideo Code Thủ giúp mình biết chọn mảng khi dữ liệu cố định trước, dùng ArrayList khi cần mở rộng.\nBiết kết hợp duyệt mảng, thao tác cơ bản sẽ cực kỳ thuận lợi cho các bài toán lớn hơn.\nTiếp theo: Bài 7 – HashMap \u0026amp; Set\r","date":"2025-09-22T11:30:00+07:00","image":"https://img.youtube.com/vi/uzZ8rwgkPqU/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-6-m%E1%BA%A3ng-array-v%C3%A0-arraylist-trong-java/","title":"Bài 6 - Mảng (Array) và ArrayList trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Câu lệnh điều kiện if-else\rDùng để kiểm tra điều kiện, phân nhánh logic chương trình.\nint age = 19; if (age \u0026gt;= 18) { System.out.println(\u0026#34;Bạn đủ tuổi!\u0026#34;); } else { System.out.println(\u0026#34;Bạn chưa đủ tuổi.\u0026#34;); } 2) Vòng lặp While\rDùng lặp khi chưa biết trước số lần lặp, lặp khi điều kiện còn đúng.\nint i = 0; while (i \u0026lt; 5) { System.out.println(\u0026#34;i = \u0026#34; + i); i++; } 3) Vòng lặp For\rDùng lặp biết trước số lần, cấu trúc gồm khởi tạo, điều kiện, bước nhảy.\nfor (int j = 1; j \u0026lt;= 3; j++) { System.out.println(\u0026#34;j = \u0026#34; + j); } 4) Kết hợp điều kiện và vòng lặp\rỨng dụng kiểm tra số chẵn/lẻ, tổng dãy số, lọc dữ liệu, \u0026hellip;\nfor (int k = 0; k \u0026lt; 10; k++) { if (k % 2 == 0) { System.out.println(k + \u0026#34; là số chẵn\u0026#34;); } } 5) Lời khuyên \u0026amp; cảm nhận\rNhờ video Code Thủ, mình hiểu rõ từng loại vòng lặp, điều kiện và biết áp dụng chọn đúng tình huống giúp mã nguồn ngắn gọn, hiệu quả.\nKhi học thao tác vòng lặp, đừng quên điều kiện dừng để tránh lỗi infinite loop!\nTiếp theo: Bài 6 – Mảng \u0026amp; ArrayList\r","date":"2025-09-22T11:00:00+07:00","image":"https://img.youtube.com/vi/u4kJ-pUKaiQ/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-5-c%C3%A2u-%C4%91i%E1%BB%81u-ki%E1%BB%87n-if-else-v%C3%A0-v%C3%B2ng-l%E1%BA%B7p-trong-java/","title":"Bài 5 - Câu điều kiện (if-else) và Vòng lặp trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Khái niệm Class trong Java\rClass là bản thiết kế cho đối tượng – mô tả thuộc tính (biến) và hành động (phương thức) chung cho một loại sự vật.\nKhi tạo object (đối tượng) từ class, ta sử dụng bản thiết kế này để sinh ra thực thể thật dùng trong chương trình.\nVí dụ:\nclass Student { String name; int age; void introduce() { System.out.println(name + \u0026#34; - \u0026#34; + age); } } Student s = new Student(); s.name = \u0026#34;An\u0026#34;; s.age = 20; s.introduce(); // In: An - 20 2) Constructor (Hàm tạo) là gì?\rConstructor là một phương thức đặc biệt dùng để khởi tạo đối tượng từ class.\nTên constructor trùng tên class, không có kiểu trả về, gọi tự động khi dùng từ khóa new.\nVí dụ:\npublic class Student { String name; public Student(String studentName) { name = studentName; } } Student sv = new Student(\u0026#34;Nam\u0026#34;); System.out.println(sv.name); // Nam 3) Default Constructor \u0026amp; Overloading\rNếu bạn không tạo constructor, Java tự thêm constructor mặc định (không nhận tham số).\nCó thể tạo nhiều constructor với tham số khác nhau (constructor overloading).\nVí dụ:\npublic class Student { String name; int age; public Student() { name = \u0026#34;No Name\u0026#34;; age = 0; } public Student(String n, int a) { name = n; age = a; } } Student s1 = new Student(); Student s2 = new Student(\u0026#34;Long\u0026#34;, 22); 4) Khái niệm THIS\rTừ khóa this đại diện cho đối tượng hiện tại, dùng để phân biệt biến thành phần và tham số trong constructor hoặc phương thức.\npublic Student(String name) { this.name = name; } 5) Kết luận \u0026amp; cảm nhận\rXem video của Code Thủ giúp mình hiểu gốc rễ về cách tạo/làm việc với class, sử dụng constructor linh hoạt và phân biệt rõ giữa biến thành phần - biến cục bộ.\nClass, constructor và kỹ năng dùng this chuẩn xác là chìa khoá lập trình OOP Java hiệu quả.\nTiếp theo: Bài 5 – Điều kiện \u0026amp; vòng lặp\r","date":"2025-09-22T10:30:00+07:00","image":"https://img.youtube.com/vi/n33H9XSXRxc/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-4-l%E1%BB%9Bp-class-v%C3%A0-constructor-trong-java/","title":"Bài 4 - Lớp (Class) và Constructor trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) String là gì?\rString là một kiểu tham chiếu (class) trong Java, dùng lưu chuỗi ký tự (text).\nBất cứ thứ gì nằm giữa cặp dấu ngoặc kép (\u0026quot;\u0026quot;) đều là String.\nVí dụ:\nString msg = \u0026#34;Hello Code Thủ\u0026#34;; 2) Tính bất biến (immutable)\rString trong Java bất biến: Khi thay đổi giá trị, đối tượng mới được tạo, giá trị cũ không bị thay đổi.\nVí dụ:\nString s1 = \u0026#34;Java\u0026#34;; String s2 = s1; s1 = \u0026#34;Hello\u0026#34;; System.out.println(s2); // vẫn in \u0026#34;Java\u0026#34; 3) Các thao tác phổ biến với String\rNối chuỗi (sử dụng toán tử +):\nString s = \u0026#34;Hello \u0026#34; + \u0026#34;Code Thủ\u0026#34;; System.out.println(s); // Hello Code Thủ Nối chuỗi với biến/giá trị:\nint number = 123; System.out.println(\u0026#34;Code Thủ \u0026#34; + number); // Code Thủ 123 4) Một số phương thức hữu ích\r.length(): Độ dài chuỗi. .toUpperCase(), .toLowerCase(): Chuyển chuỗi sang chữ hoa/thường. .indexOf(): Vị trí đầu tiên tìm thấy ký tự/chuỗi con, -1 nếu không có. .replace(old, new): Thay thế tất cả ký tự/chuỗi con phù hợp bằng chuỗi khác. .trim(): Loại bỏ khoảng trắng đầu/cuối chuỗi. .isEmpty(): Kiểm tra chuỗi có rỗng không. String name = \u0026#34; Code Thủ \u0026#34;; System.out.println(name.trim().toUpperCase()); // CODE THỦ 5) So sánh String\rQuan trọng: Không so sánh giá trị chuỗi bằng hai dấu == mà phải dùng .equals() hoặc .equalsIgnoreCase().\nString a = \u0026#34;Java\u0026#34;; String b = \u0026#34;JAVA\u0026#34;; System.out.println(a.equals(b)); // false System.out.println(a.equalsIgnoreCase(b)); // true 6) Kết luận \u0026amp; cảm nhận\rVideo Code Thủ giúp mình hiểu sâu về bản chất \u0026ldquo;bất biến\u0026rdquo; của chuỗi, thao tác nối/chỉnh sửa, so sánh chuẩn không lỗi logic.\nBiết cách dùng method hữu ích của String giúp làm việc nhanh hơn và tránh bug khó đoán lúc kiểm tra điều kiện hoặc nhập xuất.\nTiếp theo: Bài 4 – Array \u0026amp; List\r","date":"2025-09-22T10:00:00+07:00","image":"https://img.youtube.com/vi/14MHZ23g0eI/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-3-l%C3%A0m-ch%E1%BB%A7-string-trong-java/","title":"Bài 3 - Làm chủ String trong Java"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1. Kiểu dữ liệu boolean\rboolean là kiểu dữ liệu cơ bản trong Java Chỉ có 2 giá trị: true hoặc false Dùng để lưu trữ điều kiện đúng/sai boolean isJavaFun = true; boolean isBoring = false; 2. Các phép toán logic\rPhép AND (\u0026amp;\u0026amp;)\rTrả về true khi cả 2 đều true boolean a = true; boolean b = true; System.out.println(a \u0026amp;\u0026amp; b); // true b = false; System.out.println(a \u0026amp;\u0026amp; b); // false Phép OR (||)\rTrả về true khi có ít nhất 1 true boolean x = true; boolean y = false; System.out.println(x || y); // true x = false; System.out.println(x || y); // false Phép NOT (!)\rĐảo ngược giá trị boolean boolean done = true; System.out.println(!done); // false 3. So sánh bằng (==) và khác (!=)\rint num1 = 5; int num2 = 5; boolean isEqual = (num1 == num2); // true boolean isNotEqual = (num1 != num2); // false 4. Ứng dụng trong câu điều kiện if\rboolean isRaining = true; if (isRaining) { System.out.println(\u0026#34;Mang ô đi!\u0026#34;); } else { System.out.println(\u0026#34;Thời tiết đẹp!\u0026#34;); } 5. Một số ví dụ thực tế\rKiểm tra số chẵn lẻ\rint number = 10; boolean isEven = (number % 2 == 0); System.out.println(number + \u0026#34; là số chẵn: \u0026#34; + isEven); Kiểm tra tuổi hợp lệ\rint age = 20; boolean isAdult = age \u0026gt;= 18; System.out.println(\u0026#34;Đủ tuổi trưởng thành: \u0026#34; + isAdult); 6. Lưu ý quan trọng\rKhông dùng số 1/0 thay cho true/false boolean giúp code dễ đọc, dễ hiểu Nên đặt tên biến boolean bắt đầu bằng is/has/can Tiếp theo: Bài 3 – Biến số\r","date":"2025-09-22T09:30:00+07:00","image":"https://img.youtube.com/vi/iscik6EOcMo/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-2-boolean-c%C3%A1i-%C4%91%C3%BAng-c%C3%A1i-sai-trong-java/","title":"Bài 2 - Boolean - Cái Đúng Cái Sai trong JAVA"},{"content":"🎥 Video minh họa nguồn: YTB Code Thu\r1) Chuẩn bị môi trường Java\rTải về JDK (khuyên dùng Temurin hoặc Oracle JDK).\nCài đặt xong, kiểm tra trên terminal/cmd:\njava -version javac -version Thiết lập biến môi trường JAVA_HOME nếu cần cho dự án/IDE.\n2) Cài đặt IDE chuyên dụng\rIntelliJ IDEA Community Edition (Code Thủ hướng dẫn thao tác siêu nhanh)\nHoặc VS Code (cài Java Extension Pack)\nIDE miễn phí, dễ thao tác cho người mới.\n3) Tạo Project \u0026amp; file đầu tiên (Hello World)\rTrong IntelliJ: File \u0026gt; New \u0026gt; Project, chọn Java, rồi tạo file Hello.java trong thư mục src.\nCấu trúc dự án đơn giản:\nProjectRoot/ └── src/ └── Hello.java 4) Viết chương trình đầu tiên\rpublic class Hello { public static void main(String[] args) { System.out.println(\u0026#34;Hello, Java!\u0026#34;); } } Build và chạy bằng nút Run trên IDE, hoặc dùng dòng lệnh: javac Hello.java java Hello Màn hình in ra: Hello, Java! 5) Kết luận \u0026amp; cảm nhận\rSau khi xem video của Code Thủ, mình cài đặt Java, thiết lập IDE và chạy chương trình đầu tiên cực kỳ nhanh, y như hướng dẫn!\nViệc xây dựng dự án Java và chạy mã nguồn đơn giản giúp mình tự tin bắt đầu học các phần tiếp theo.\nTiếp theo: Bài 2 – boolean\r","date":"2025-09-22T09:00:00+07:00","image":"https://img.youtube.com/vi/uWdaOoMgFvs/maxresdefault.jpg","permalink":"https://nguyenwoong20.github.io/MyPortfolio/p/b%C3%A0i-1-gi%E1%BB%9Bi-thi%E1%BB%87u-java-m%C3%B4i-tr%C6%B0%E1%BB%9Dng-l%E1%BA%ADp-tr%C3%ACnh-hello-world/","title":"Bài 1 - Giới thiệu Java \u0026 môi trường lập trình (Hello World)"}]